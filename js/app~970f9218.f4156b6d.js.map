{"version":3,"sources":["webpack:///./src/js/wallets/MnemonicWallet.ts","webpack:///./src/js/ERC721Token.ts","webpack:///./src/js/AvaNetwork.ts","webpack:///./src/js/Erc20Token.ts","webpack:///./src/js/TxHelper.ts","webpack:///./src/js/Crypto.ts","webpack:///./src/js/Keystore.ts","webpack:///./src/js/HdHelper.ts","webpack:///./src/js/wallets/HdWalletCore.ts","webpack:///./src/js/wallets/LedgerWallet.ts","webpack:///./src/kyc_api.ts","webpack:///./src/locales/lang_map.js","webpack:///./src/js/wallets/MnemonicPhrase.ts","webpack:///./src/js/wallets/SingletonWallet.ts","webpack:///./src/js/AvaNftFamily.ts","webpack:///./src/js/wallets/WalletCore.ts","webpack:///./src/js/AvaAsset.ts"],"names":["AVA_TOKEN_INDEX","AVA_ACCOUNT_PATH","ETH_ACCOUNT_PATH","LEDGER_ETH_ACCOUNT_PATH","mnemonic","seed","masterHdKey","fromMasterSeed","accountHdKey","derive","ethAccountKey","ethPrivateKey","privateKey","ethKey","toString","ethAddress","ethBalance","cPrivKey","cb58Encode","from","ethKeyBech","cKeyChain","getHRP","ethKeyChain","importKey","type","hdKey","isLoading","onnetworkchange","this","getEvmAddress","getEthBalance","bal","sendEth","to","amount","gasPrice","gasLimit","estimateGas","token","Promise","sendERC20","sendErc20","getUTXOs","isFetchUtxos","isInit","externalHelper","internalHelper","platformHelper","getStake","setTimeout","getCurrentKey","getMnemonic","getValue","getMnemonicEncrypted","validate","nodeID","amt","start","end","delegationFee","rewardAddress","utxos","delegate","stakeAmount","issueBatchTx","orders","addr","memo","getKeyChain","internal","getAllDerivedKeys","external","allKeys","concat","keychain","getNetworkID","chainId","i","length","addKey","signX","unsignedTx","tx","sign","signP","getKeychain","signC","keyChain","signEvm","keyBuff","Buffer","signHashByExternalIndex","index","hash","key","getKeyForIndex","signed","createNftFamily","name","symbol","groupNum","mintNft","mintUtxo","payload","quantity","ERC721MetadataID","ERC721EnumerableID","data","tokenCache","uriDataCache","canSupport","contractAddress","address","contract","eth","Contract","abi","updateSupports","methods","supportsInterface","call","metadata","enumerable","getBalance","balanceOf","getAllTokensIds","res","tokenOfOwnerByIndex","tokenId","push","getAllTokenData","ids","id","getTokenURI","parseInt","createTransferTx","transferFrom","tokenURI","getTokenURIData","uri","a","get","network_id","url","networkId","explorerUrl","explorerSiteUrl","readonly","withCredentials","protocol","port","ip","updateURL","testConnection","credentials","post","jsonrpc","method","err","updateCredentials","split","includes","urlSplit","getFullURL","getWsUrlX","getWsUrlC","tokenData","balanceRaw","balanceBN","balanceBig","tokenInst","fromAddress","console","log","transfer","updateBalance","decimals","AvmTxNameEnum","PlatfromTxNameEnum","ParseableAvmTxEnum","ParseablePlatformEnum","ParseableEvmTxEnum","buildUnsignedTransaction","derivedAddresses","utxoset","changeAddress","fromAddrsStr","fromAddrs","map","val","parseAddress","changeAddr","stringToAddress","getDJTXAssetID","DJTX_ID_BUF","DJTX_ID_STR","TO_BUF","aad","ZERO","isFeeAdded","order","asset","assetId","cb58Decode","addAssetAmount","getTxFee","gt","success","getMinimumSpendable","ins","outs","getInputs","getAllOutputs","nftUtxos","filter","getBlockchainID","nftSet","addArray","utxoIds","getUTXOIDs","sort","b","buildNFTTransferTx","undefined","rawTx","getTransaction","outsNft","getOuts","insNft","getIns","baseTx","buildCreateNftFamilyTx","minterAddr","utxoSet","fromAddresses","minterAddress","minterSets","minterSet","buildCreateNFTAssetTx","buildMintNftTx","ownerAddress","addrBuf","owners","sourceAddresses","owner","groupID","getOutput","getGroupID","buildCreateNFTMintTx","getUTXOID","mintTx","buildEvmTransferNativeTx","getTransactionCount","nonce","getChainId","net","getId","chainParams","common","forCustomChain","value","buildEvmTransferErc20Tx","tokenTx","encodeABI","buildEvmTransferErc721Tx","BASETX","CREATEASSETTX","OPERATIONTX","IMPORTTX","EXPORTTX","ADDVALIDATORTX","ADDDELEGATORTX","ADDSUBNETVALIDATORTX","CREATECHAINTX","CREATESUBNETTX","ADVANCETIMETX","REWARDVALIDATORTX","ivSize","saltSize","tagLength","aesLength","keygenIterations","_pwcleaner","password","slt","pw","sha256","_keyMaterial","pwkey","window","crypto","subtle","Uint8Array","_deriveKey","keyMaterial","salt","deriveKey","iterations","message","buff","update","digest","makeSalt","alloc","getRandomValues","pwhash","encrypt","plaintext","pt","pkey","iv","additionalData","ciphertext","decrypt","cryptoHelpers","Crypto","KEYSTORE_VERSION","ITERATIONS_V2","ITERATIONS_V3","readV2","pass","version","pass_hash","checkHash","checkHashString","keys","keysDecrypt","key_data","key_decrypt","key_string","activeIndex","readV3","readV4","readV5","readV6","readKeyFile","extractKeysV2","file","chainID","getBlockchainAlias","pk","keypair","keyBuf","getPrivateKey","keyHex","paddedKeyHex","padStart","extractKeysV5","extractKeysV6","extractKeysFromDecryptedFile","makeKeyfile","wallets","wallet","pk_crypt","file_data","INDEX_RANGE","SCAN_SIZE","SCAN_RANGE","changePath","masterKey","isPublic","isFetchUtxo","hrp","keyCache","addressCache","hdCache","hdIndex","oninit","findHdIndex","onNetworkChange","clearCache","incrementIndex","newIndex","newKey","network","store","state","Network","selectedNetwork","findAvailableIndexExplorer","findAvailableIndexNode","updateKeychain","updateUtxos","error","addrs","getAllDerivedAddresses","result","currentAddr","getCurrentAddress","currentAddrBuf","currentUtxos","getExtendedAddresses","getUtxos","upTo","set","getAddressForIndex","startIndex","addrChains","gapSize","n","scanIndex","scanAddr","rawAddr","chains","addrUTXOs","targetIndex","getFirstAvailableIndex","getFirstAvailableAddress","idx","isPrivate","cacheExternal","pkHex","derivationPath","publicKey","pkBuf","pkBuff","addressFromPublicKey","addressToString","findAddressIndex","indexOf","ethHdNode","accountNodeXP","then","updateInitState","getXpubXP","toJSON","xpub","getEvmAddressBech","pubKeyHash","updateAvmUTXOSet","setExternal","setInternal","joined","merge","getFirstAvailableAddressPlatform","updateFetchState","updateUTXOsX","updateUTXOsP","updateUTXOsExternal","updateUTXOsInternal","getAllDerivedExternalAddresses","getDerivedAddresses","getDerivedAddressesP","getAllAddressesX","getAllAddressesP","getHistoryAddresses","internalIndex","externalIndex","Math","max","getCurrentAddressAvm","getChangeAddressAvm","getChangeAddressPlatform","getChangePath","getChangeIndex","getChangeFromIndex","getPlatformRewardAddress","getCurrentAddressPlatform","getPlatformUTXOSet","getPlatformActiveIndex","getExternalActiveIndex","getBaseAddress","getUTXOSet","findExternalAddressIndex","indexX","indexP","Error","signMessageByExternalAddress","msgStr","signMessageByExternalIndex","digestHex","digestBuff","signMessage","msg","WalletCore","bippath","MIN_EVM_SUPPORT_V","app","hdkey","config","hdEth","ethApp","ethPublic","fromApp","getWalletExtendedPublicKey","hd","public_key","chainCode","chain_code","getAddress","ethRes","LedgerWallet","getTransactionPaths","toBuffer","txType","getTxType","operations","getOperations","e","items","getImportInputs","paths","isDjtxOnly","item","getAssetID","Assets","AVA_ASSET_ID","sigidxs","getInput","getSigIdxs","sources","sigidx","source","j","srcAddr","pathStr","getPathFromAddress","op","getOperation","pathsToUniqueBipPaths","uniquePaths","bip32Paths","path","fromString","getChangeBipPath","chainChangePath","changeIdx","getCredentials","sigMap","CredentialClass","creds","evmInputs","cred","getCredentialID","pathIndex","sigRaw","sigBuff","sig","fromBuffer","addSignature","evmInput","signTransactionHash","txbuff","commit","title","messages","info","toUpperCase","accountPathSource","accountPath","signHash","signedTx","signTransactionParsable","parseableTxs","X","P","C","getTransactionMessages","signTransaction","ledgerSignedTx","signatures","getOutputMsgs","getExportOutputs","getExportedOutputs","destinationChain","getAmount","toPathArray","getAddresses","forEach","getValidateDelegateMsgs","format","getNodeID","startTime","getStartTime","toNumber","utc","endTime","getEndTime","stakeAmt","getStakeAmount","rewardOwners","getRewardOwners","rewardAddrs","join","getFeeMsgs","outputMessages","validateDelegateMessages","feeMessages","getEvmTransactionMessages","totFee","mul","feeNano","msgs","test","decodeMethod","callMsg","paramMsgs","params","param","feeMsg","toLocaleString","canLedgerParse","isParsableType","txIns","typeID","getTypeID","STAKEABLELOCKINID","destChainBuff","getDestinationChain","destChain","sourceChainBuff","getSourceChain","sourceChain","typeId","input","txSigned","rawUnsignedTx","encode","buf","signature","signatureBN","v","r","s","fromTxData","externalAddrs","internalAddrs","platformAddrs","extIndex","intIndex","platformIndex","addressPath","elliptic","ec","BASE_URL","kyc_api","create","baseURL","headers","getNonce","getPublicKey","keyPair","keyFromPrivate","pubKey","getPublic","generateToken","privKey","getPrivate","msgHash","keccak_256","canonical","req","toArrayLike","recoveryParam","isoLangs","ab","nativeName","aa","af","ak","sq","am","ar","an","hy","as","av","ae","ay","az","bm","ba","eu","be","bn","bh","bi","bs","br","bg","my","ca","ch","ce","ny","cn","zh_hans","zh_hant","cv","kw","co","cr","hr","cs","da","dv","nl","en","eo","et","ee","fo","fj","fi","fr","ff","gl","ka","de","el","gn","gu","ht","ha","he","hz","hi","ho","hu","ia","ie","ga","ig","ik","io","is","it","iu","ja","jv","kl","kn","ks","kk","km","ki","rw","ky","kv","kg","kr","ku","kj","la","lb","lg","li","ln","lo","lt","lu","lv","gv","mk","mg","ms","ml","mt","mi","mr","mh","mn","na","nv","nb","nd","ne","ng","nn","no","ii","nr","oc","oj","cu","om","or","os","pa","pi","fa","pl","ps","qu","rm","rn","ro","ru","sa","sc","sd","se","sm","sg","sr","gd","sn","si","sk","sl","so","st","es","su","sw","ss","sv","ta","te","tg","th","ti","bo","tk","tl","tn","tr","ts","tt","tw","ty","ug","uk","ur","uz","ve","vn","vo","wa","cy","wo","fy","xh","yi","yo","za","randomstring","generate","encrypted","decrypted","enc","Utf8","chainIdP","platformKeyChain","platformKeyPair","pkBuffNative","cKeypair","ethAddressBech","getAddressString","getExtendedPlatformAddresses","platformUtxoset","uniqid","evmGetAtomicUTXOs","createImportTxC","fee","bechAddr","hexAddr","toAddress","ownerAddresses","sourceChainId","buildImportTx","importToCChain","getAllUTXOs","unsignedTxFee","issueC","issueX","issueP","exportFromXChain","importFee","amtFee","clone","destinationAddr","add","buildAvmExportTransaction","exportTx","exportFromPChain","pChangeAddr","buildPlatformExportTransaction","exportFromCChain","exportFee","buildEvmExportTransaction","estimateExportFee","estimateExportGasFee","avmGetAtomicUTXOs","platformGetAtomicUTXOs","importToPlatformChain","pToAddr","utxoAddrs","ownerAddrs","importToXChain","xToAddr","denomination","amountLocked","amountExtra","amountMultisig","pow","addBalance","addBalanceLocked","addBalanceMultisig","addExtra","resetBalance","locked","div","getAmountBN","getTotalAmount","toStringTotal","big"],"mappings":"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","file":"js/app~970f9218.f4156b6d.js","sourcesContent":["// A simple wrapper thar combines avalanche.js, bip39 and HDWallet\n\nimport {\n  KeyPair as AVMKeyPair,\n  KeyChain as AVMKeyChain,\n  UTXOSet as AVMUTXOSet,\n  TransferableInput,\n  TransferableOutput,\n  BaseTx,\n  UnsignedTx as AVMUnsignedTx,\n  Tx as AVMTx,\n  UTXO as AVMUTXO,\n  AssetAmountDestination,\n  UTXOSet,\n} from \"avalanche/dist/apis/avm\";\n\nimport { privateToAddress } from \"ethereumjs-util\";\n\nimport {\n  KeyChain as PlatformVMKeyChain,\n  UnsignedTx as PlatformUnsignedTx,\n  UTXO as PlatformUTXO,\n  Tx as PlatformTx,\n} from \"avalanche/dist/apis/platformvm\";\n\nimport {\n  KeyChain as EVMKeyChain,\n  UnsignedTx as EVMUnsignedTx,\n  Tx as EvmTx,\n} from \"avalanche/dist/apis/evm\";\nimport { getPreferredHRP, PayloadBase } from \"avalanche/dist/utils\";\n\nimport * as bip39 from \"bip39\";\nimport { BN, Buffer as BufferAvalanche } from \"avalanche\";\nimport { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport {\n  AvmExportChainType,\n  AvmImportChainType,\n  IAvaHdWallet,\n} from \"@/js/wallets/types\";\nimport HDKey from \"hdkey\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport { KeyPair as PlatformVMKeyPair } from \"avalanche/dist/apis/platformvm\";\nimport { HdWalletCore } from \"@/js/wallets/HdWalletCore\";\nimport { WalletNameType } from \"@/js/wallets/types\";\nimport { digestMessage } from \"@/helpers/helper\";\nimport { KeyChain } from \"avalanche/dist/apis/evm\";\nimport Erc20Token from \"@/js/Erc20Token\";\nimport { WalletHelper } from \"@/helpers/wallet_helper\";\nimport { Transaction } from \"@ethereumjs/tx\";\nimport MnemonicPhrase from \"@/js/wallets/MnemonicPhrase\";\nimport { ExportChainsC, ExportChainsP } from \"@avalabs/avalanche-wallet-sdk\";\n\n// HD WALLET\n// Accounts are not used and the account index is fixed to 0\n// m / purpose' / coin_type' / account' / change / address_index\n\nconst AVA_TOKEN_INDEX: string = \"9000\";\nexport const AVA_ACCOUNT_PATH: string = `m/44'/${AVA_TOKEN_INDEX}'/0'`; // Change and index left out\nexport const ETH_ACCOUNT_PATH: string = `m/44'/60'/0'`;\nexport const LEDGER_ETH_ACCOUNT_PATH = ETH_ACCOUNT_PATH + \"/0/0\";\n\nconst INDEX_RANGE: number = 20; // a gap of at least 20 indexes is needed to claim an index unused\nconst SCAN_SIZE: number = 70; // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE; // How many items are actually scanned\n\n// Possible indexes for each request is\n// SCAN_SIZE - INDEX_RANGE\n\nexport default class MnemonicWallet\n  extends HdWalletCore\n  implements IAvaHdWallet {\n  seed: string;\n  hdKey: HDKey;\n  private mnemonic: MnemonicPhrase;\n  isLoading: boolean;\n  type: WalletNameType;\n  ethKey: string;\n  ethKeyBech: string;\n  ethKeyChain: EVMKeyChain;\n  ethAddress: string;\n  ethBalance: BN;\n\n  // TODO : Move to hd core class\n  onnetworkchange() {\n    super.onnetworkchange();\n\n    // Update EVM values\n    this.ethKeyChain = new EVMKeyChain(ava.getHRP(), \"C\");\n    const cKeypair = this.ethKeyChain.importKey(this.ethKeyBech);\n    this.ethBalance = new BN(0);\n  }\n\n  // The master key from avalanche.js\n  constructor(mnemonic: string) {\n    const seed: globalThis.Buffer = bip39.mnemonicToSeedSync(mnemonic);\n    const masterHdKey: HDKey = HDKey.fromMasterSeed(seed);\n    const accountHdKey = masterHdKey.derive(AVA_ACCOUNT_PATH);\n    const ethAccountKey = masterHdKey.derive(ETH_ACCOUNT_PATH + \"/0/0\");\n\n    super(accountHdKey, ethAccountKey, false);\n\n    // Derive EVM key and address\n    const ethPrivateKey = ethAccountKey.privateKey;\n    this.ethKey = ethPrivateKey.toString(\"hex\");\n    this.ethAddress = privateToAddress(ethPrivateKey).toString(\"hex\");\n    this.ethBalance = new BN(0);\n\n    const cPrivKey =\n      `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(ethPrivateKey));\n    this.ethKeyBech = cPrivKey;\n\n    const cKeyChain = new KeyChain(ava.getHRP(), \"C\");\n    this.ethKeyChain = cKeyChain;\n\n    const cKeypair = cKeyChain.importKey(cPrivKey);\n\n    this.type = \"mnemonic\";\n    this.seed = seed.toString(\"hex\");\n    this.hdKey = masterHdKey;\n    this.mnemonic = new MnemonicPhrase(mnemonic);\n    this.isLoading = false;\n  }\n\n  getEvmAddress(): string {\n    return this.ethAddress;\n  }\n\n  async getEthBalance() {\n    const bal = await WalletHelper.getEthBalance(this);\n    this.ethBalance = bal;\n    return bal;\n  }\n\n  async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n    return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit);\n  }\n\n  async estimateGas(\n    to: string,\n    amount: BN,\n    token: Erc20Token\n  ): Promise<number> {\n    return await WalletHelper.estimateGas(this, to, amount, token);\n  }\n\n  async sendERC20(\n    to: string,\n    amount: BN,\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n  ): Promise<string> {\n    return await WalletHelper.sendErc20(\n      this,\n      to,\n      amount,\n      gasPrice,\n      gasLimit,\n      token\n    );\n  }\n\n  async getUTXOs(): Promise<void> {\n    // TODO: Move to shared file\n    this.isFetchUtxos = true;\n    // If we are waiting for helpers to initialize delay the call\n    const isInit =\n      this.externalHelper.isInit &&\n      this.internalHelper.isInit &&\n      this.platformHelper.isInit;\n    if (!isInit) {\n      setTimeout(() => {\n        this.getUTXOs();\n      }, 1000);\n      return;\n    }\n\n    super.getUTXOs();\n    this.getStake();\n    this.getEthBalance();\n    return;\n  }\n\n  getCurrentKey(): AVMKeyPair {\n    return this.externalHelper.getCurrentKey() as AVMKeyPair;\n  }\n\n  /**\n   * Returns the mnemonic phrase of this wallet\n   */\n  getMnemonic(): string {\n    return this.mnemonic.getValue();\n  }\n\n  getMnemonicEncrypted(): MnemonicPhrase {\n    return this.mnemonic;\n  }\n\n  async validate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    delegationFee: number = 0,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.validate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      delegationFee,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  // Delegates DJTX to the given node ID\n  async delegate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.delegate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async getStake(): Promise<BN> {\n    this.stakeAmount = await WalletHelper.getStake(this);\n    return this.stakeAmount;\n  }\n\n  async issueBatchTx(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    memo: BufferAvalanche | undefined\n  ): Promise<string> {\n    return await WalletHelper.issueBatchTx(this, orders, addr, memo);\n  }\n\n  // returns a keychain that has all the derived private/public keys for X chain\n  getKeyChain(): AVMKeyChain {\n    const internal = this.internalHelper.getAllDerivedKeys() as AVMKeyPair[];\n    const external = this.externalHelper.getAllDerivedKeys() as AVMKeyPair[];\n\n    const allKeys = internal.concat(external);\n    const keychain: AVMKeyChain = new AVMKeyChain(\n      getPreferredHRP(ava.getNetworkID()),\n      this.chainId\n    );\n\n    for (let i = 0; i < allKeys.length; i++) {\n      keychain.addKey(allKeys[i]);\n    }\n    return keychain;\n  }\n\n  async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n    const keychain = this.getKeyChain();\n\n    const tx = unsignedTx.sign(keychain);\n    return tx;\n  }\n\n  async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n    const keychain = this.platformHelper.getKeychain() as PlatformVMKeyChain;\n    const tx = unsignedTx.sign(keychain);\n    return tx;\n  }\n\n  async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n    const keyChain = this.ethKeyChain;\n    return unsignedTx.sign(keyChain);\n  }\n\n  async signEvm(tx: Transaction) {\n    const keyBuff = Buffer.from(this.ethKey, \"hex\");\n    return tx.sign(keyBuff);\n  }\n\n  async signHashByExternalIndex(index: number, hash: BufferAvalanche) {\n    const key = this.externalHelper.getKeyForIndex(index) as AVMKeyPair;\n    const signed = key.sign(hash);\n    return bintools.cb58Encode(signed);\n  }\n\n  async createNftFamily(name: string, symbol: string, groupNum: number) {\n    return await WalletHelper.createNftFamily(this, name, symbol, groupNum);\n  }\n\n  async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n    return await WalletHelper.mintNft(this, mintUtxo, payload, quantity);\n  }\n}\n","import { web3 } from \"@/evm\";\nimport ERC721Abi from \"@openzeppelin/contracts/build/contracts/ERC721Enumerable.json\";\nimport { ERC721TokenInput } from \"@/store/modules/assets/modules/types\";\nimport axios from \"axios\";\n\ninterface TokenDataCache {\n  [index: number]: string;\n}\n\ninterface URIDataCache {\n  [index: number]: string;\n}\n\nconst ERC721MetadataID = \"0x5b5e139f\";\nconst ERC721EnumerableID = \"0x780e9d63\";\n\nclass ERC721Token {\n  contractAddress: string;\n  contract: any;\n  name = \"\";\n  symbol = \"\";\n  data: ERC721TokenInput;\n  tokenCache: TokenDataCache = {};\n  uriDataCache: URIDataCache = {};\n  canSupport = false;\n\n  constructor(data: ERC721TokenInput) {\n    this.contractAddress = data.address;\n    this.name = data.name;\n    this.symbol = data.symbol;\n    this.data = data;\n    //@ts-ignore\n    this.contract = new web3.eth.Contract(ERC721Abi.abi, this.contractAddress);\n    this.updateSupports();\n  }\n\n  async updateSupports() {\n    try {\n      const metadata = await this.contract.methods\n        .supportsInterface(ERC721MetadataID)\n        .call();\n      const enumerable = await this.contract.methods\n        .supportsInterface(ERC721EnumerableID)\n        .call();\n      this.canSupport = metadata && enumerable;\n    } catch (err) {\n      this.canSupport = false;\n    }\n  }\n\n  async getBalance(address: string) {\n    return await this.contract.methods.balanceOf(address).call();\n  }\n\n  async getAllTokensIds(address: string): Promise<string[]> {\n    if (!this.canSupport) return [];\n\n    const bal = await this.getBalance(address);\n    const res = [];\n    for (let i = 0; i < bal; i++) {\n      const tokenId = await this.contract.methods\n        .tokenOfOwnerByIndex(address, i)\n        .call();\n      res.push(tokenId);\n    }\n    return res;\n  }\n\n  async getAllTokenData(address: string) {\n    const ids = await this.getAllTokensIds(address);\n\n    const res = [];\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const data = await this.getTokenURI(parseInt(id));\n      res.push(data);\n    }\n    return res;\n  }\n\n  createTransferTx(from: string, to: string, id: string) {\n    return this.contract.methods.transferFrom(from, to, id);\n  }\n\n  async getTokenURI(id: number) {\n    if (this.tokenCache[id]) return this.tokenCache[id];\n    const data = await this.contract.methods.tokenURI(id).call();\n    this.tokenCache[id] = data;\n    return data;\n  }\n\n  async getTokenURIData(id: number): Promise<any> {\n    //Check cache\n    if (this.uriDataCache[id]) return this.uriDataCache[id];\n    const uri = await this.getTokenURI(id);\n    if (!uri) return null;\n    const res = (await axios.get(uri)).data;\n    //Save to cache\n    this.uriDataCache[id] = res;\n    return res;\n  }\n}\n\nexport default ERC721Token;\n","import axios from \"axios\";\n\nlet network_id: number = 0;\n\nclass AvaNetwork {\n  name: string;\n  id: number;\n  protocol: string;\n  port: number;\n  ip: string;\n  networkId: number;\n  // chainId: string;\n  url: string;\n  explorerUrl: string | undefined;\n  explorerSiteUrl: string | undefined;\n  readonly: boolean;\n  withCredentials = false;\n  // fee: BN\n\n  constructor(\n    name: string,\n    url: string,\n    networkId: number,\n    explorerUrl?: string,\n    explorerSiteUrl?: string,\n    readonly = false\n  ) {\n    this.id = network_id++;\n    this.name = name;\n    this.explorerUrl = explorerUrl;\n    this.explorerSiteUrl = explorerSiteUrl;\n    this.protocol = \"http\";\n    this.port = 9650;\n    this.ip = \"localhost\";\n    this.url = url;\n    this.updateURL(url);\n    this.networkId = networkId;\n    // this.chainId = chainId;\n    this.readonly = readonly;\n    // this.fee = new BN(0);\n  }\n\n  async testConnection(credentials = false) {\n    const resp = await axios\n      .post(\n        this.url + \"/ext/info\",\n        {\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"info.getNetworkID\",\n        },\n        {\n          withCredentials: true,\n        }\n      )\n      .catch((err) => {\n        return false;\n      });\n\n    return true;\n  }\n\n  // Checks if this network endpoint allows credentials\n  async updateCredentials() {\n    try {\n      const res = await axios.post(\n        this.url + \"/ext/info\",\n        {\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"info.getNetworkID\",\n        },\n        {\n          withCredentials: true,\n        }\n      );\n      this.withCredentials = true;\n    } catch (e) {\n      this.withCredentials = false;\n    }\n  }\n\n  updateURL(url: string) {\n    const split: string[] = url.split(\"://\");\n\n    this.protocol = split[0];\n\n    // port is set\n    if (split[1].includes(\":\")) {\n      const urlSplit: string[] = split[1].split(\":\");\n      const ip: string = urlSplit[0];\n      const port: string = urlSplit[1];\n\n      this.ip = ip;\n      this.port = parseInt(port);\n    } else {\n      this.ip = split[1];\n      if (this.protocol === \"http\") {\n        this.port = 80;\n      } else {\n        this.port = 443;\n      }\n    }\n  }\n  getFullURL() {\n    return `${this.protocol}://${this.ip}:${this.port}`;\n  }\n\n  getWsUrlX(): string {\n    const protocol = this.protocol === \"https\" ? \"wss\" : \"ws\";\n    return `${protocol}://${this.ip}:${this.port}/ext/bc/X/events`;\n  }\n\n  getWsUrlC(): string {\n    const protocol = this.protocol === \"https\" ? \"wss\" : \"ws\";\n    return `${protocol}://${this.ip}:${this.port}/ext/bc/C/ws`;\n  }\n}\n\nexport { AvaNetwork };\n","import { TokenListToken } from \"@/store/modules/assets/types\";\nimport { web3 } from \"@/evm\";\nimport { BN } from \"avalanche\";\nimport { bnToBig } from \"@/helpers/helper\";\nimport Big from \"big.js\";\nimport store from \"@/store\";\n\nimport ERC20Abi from \"@openzeppelin/contracts/build/contracts/ERC20.json\";\n\nclass Erc20Token {\n  data: TokenListToken;\n  contract: any;\n  balanceRaw: string;\n  balanceBN: BN;\n  balanceBig: Big;\n\n  constructor(tokenData: TokenListToken) {\n    this.data = tokenData;\n    this.balanceRaw = \"0\";\n    this.balanceBN = new BN(\"0\");\n    this.balanceBig = Big(0);\n\n    //@ts-ignore\n    const tokenInst = new web3.eth.Contract(ERC20Abi.abi, tokenData.address);\n    this.contract = tokenInst;\n  }\n\n  // Returns a new instance of the token, given only the erc20 address\n  static fromAddress(address: string) {\n    //@ts-ignore\n    const tokenInst = new web3.eth.Contract(ERC20Abi.abi, address);\n    console.log(tokenInst);\n  }\n\n  createTransferTx(to: string, amount: BN) {\n    return this.contract.methods.transfer(to, amount.toString());\n  }\n\n  async updateBalance(address: string) {\n    const bal = await this.contract.methods.balanceOf(\"0x\" + address).call();\n    this.balanceRaw = bal;\n    this.balanceBN = new BN(bal);\n    this.balanceBig = bnToBig(\n      this.balanceBN,\n      parseInt(this.data.decimals as string)\n    );\n  }\n}\n\nexport default Erc20Token;\n","import { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport { BN, Buffer } from \"avalanche\";\nimport {\n  AssetAmountDestination,\n  BaseTx,\n  MinterSet,\n  NFTMintOutput,\n  TransferableInput,\n  TransferableOutput,\n  UnsignedTx as AVMUnsignedTx,\n  UTXO as AVMUTXO,\n  UTXOSet,\n  UTXOSet as AVMUTXOSet,\n  AVMConstants,\n} from \"avalanche/dist/apis/avm\";\n\nimport { PayloadBase } from \"avalanche/dist/utils\";\nimport { OutputOwners } from \"avalanche/dist/common\";\nimport { PlatformVMConstants } from \"avalanche/dist/apis/platformvm\";\n\nimport {\n  UnsignedTx as EVMUnsignedTx,\n  EVMConstants,\n} from \"avalanche/dist/apis/evm\";\n\nimport { web3 } from \"@/evm\";\nimport ERC721Token from \"@/js/ERC721Token\";\nimport { Transaction } from \"@ethereumjs/tx\";\nimport EthereumjsCommon from \"@ethereumjs/common\";\nimport Erc20Token from \"@/js/Erc20Token\";\n\nexport async function buildUnsignedTransaction(\n  orders: (ITransaction | AVMUTXO)[],\n  addr: string,\n  derivedAddresses: string[],\n  utxoset: AVMUTXOSet,\n  changeAddress?: string,\n  memo?: Buffer\n) {\n  // TODO: Get new change index.\n  if (!changeAddress) {\n    throw \"Unable to issue transaction. Ran out of change index.\";\n  }\n\n  const fromAddrsStr: string[] = derivedAddresses;\n  const fromAddrs: Buffer[] = fromAddrsStr.map((val) =>\n    bintools.parseAddress(val, \"X\")\n  );\n  const changeAddr: Buffer = bintools.stringToAddress(changeAddress);\n\n  // TODO: use internal asset ID\n  // This does not update on network change, causing issues\n  const DJTX_ID_BUF = await avm.getDJTXAssetID();\n  const DJTX_ID_STR = DJTX_ID_BUF.toString(\"hex\");\n  const TO_BUF = bintools.stringToAddress(addr);\n\n  const aad: AssetAmountDestination = new AssetAmountDestination(\n    [TO_BUF],\n    fromAddrs,\n    [changeAddr]\n  );\n  const ZERO = new BN(0);\n  let isFeeAdded = false;\n\n  // Aggregate Fungible ins & outs\n  for (let i: number = 0; i < orders.length; i++) {\n    const order: ITransaction | AVMUTXO = orders[i];\n\n    if ((order as ITransaction).asset) {\n      // if fungible\n      const tx: ITransaction = order as ITransaction;\n\n      const assetId = bintools.cb58Decode(tx.asset.id);\n      const amt: BN = tx.amount;\n\n      if (assetId.toString(\"hex\") === DJTX_ID_STR) {\n        aad.addAssetAmount(assetId, amt, avm.getTxFee());\n        isFeeAdded = true;\n      } else {\n        aad.addAssetAmount(assetId, amt, ZERO);\n      }\n    }\n  }\n\n  // If fee isn't added, add it\n  if (!isFeeAdded) {\n    if (avm.getTxFee().gt(ZERO)) {\n      aad.addAssetAmount(DJTX_ID_BUF, ZERO, avm.getTxFee());\n    }\n  }\n\n  const success: Error = utxoset.getMinimumSpendable(aad);\n\n  let ins: TransferableInput[] = [];\n  let outs: TransferableOutput[] = [];\n  if (typeof success === \"undefined\") {\n    ins = aad.getInputs();\n    outs = aad.getAllOutputs();\n  } else {\n    throw success;\n  }\n\n  //@ts-ignore\n  const nftUtxos: UTXO[] = orders.filter((val) => {\n    if ((val as ITransaction).asset) return false;\n    return true;\n  });\n\n  // If transferring an NFT, build the transaction on top of an NFT tx\n  let unsignedTx: AVMUnsignedTx;\n  const networkId: number = ava.getNetworkID();\n  const chainId: Buffer = bintools.cb58Decode(avm.getBlockchainID());\n\n  if (nftUtxos.length > 0) {\n    const nftSet = new AVMUTXOSet();\n    nftSet.addArray(nftUtxos);\n\n    const utxoIds: string[] = nftSet.getUTXOIDs();\n\n    // Sort nft utxos\n    utxoIds.sort((a, b) => {\n      if (a < b) {\n        return -1;\n      } else if (a > b) {\n        return 1;\n      }\n      return 0;\n    });\n\n    unsignedTx = nftSet.buildNFTTransferTx(\n      networkId,\n      chainId,\n      [TO_BUF],\n      fromAddrs,\n      fromAddrs, // change address should be something else?\n      utxoIds,\n      undefined,\n      undefined,\n      memo\n    );\n\n    const rawTx = unsignedTx.getTransaction();\n    const outsNft = rawTx.getOuts();\n    const insNft = rawTx.getIns();\n\n    // TODO: This is a hackish way of doing this, need methods in avalanche.js\n    //@ts-ignore\n    rawTx.outs = outsNft.concat(outs);\n    //@ts-ignore\n    rawTx.ins = insNft.concat(ins);\n  } else {\n    const baseTx: BaseTx = new BaseTx(networkId, chainId, outs, ins, memo);\n    unsignedTx = new AVMUnsignedTx(baseTx);\n  }\n  return unsignedTx;\n}\n\nexport async function buildCreateNftFamilyTx(\n  name: string,\n  symbol: string,\n  groupNum: number,\n  fromAddrs: string[],\n  minterAddr: string,\n  changeAddr: string,\n  utxoSet: UTXOSet\n) {\n  const fromAddresses = fromAddrs;\n  const changeAddress = changeAddr;\n  const minterAddress = minterAddr;\n\n  const minterSets: MinterSet[] = [];\n\n  // Create the groups\n  for (let i = 0; i < groupNum; i++) {\n    const minterSet: MinterSet = new MinterSet(1, [minterAddress]);\n    minterSets.push(minterSet);\n  }\n\n  const unsignedTx: AVMUnsignedTx = await avm.buildCreateNFTAssetTx(\n    utxoSet,\n    fromAddresses,\n    [changeAddress],\n    minterSets,\n    name,\n    symbol\n  );\n  return unsignedTx;\n}\n\nexport async function buildMintNftTx(\n  mintUtxo: AVMUTXO,\n  payload: PayloadBase,\n  quantity: number,\n  ownerAddress: string,\n  changeAddress: string,\n  fromAddresses: string[],\n  utxoSet: UTXOSet\n): Promise<AVMUnsignedTx> {\n  const addrBuf = bintools.parseAddress(ownerAddress, \"X\");\n  const owners = [];\n\n  const sourceAddresses = fromAddresses;\n\n  for (let i = 0; i < quantity; i++) {\n    const owner = new OutputOwners([addrBuf]);\n    owners.push(owner);\n  }\n\n  const groupID = (mintUtxo.getOutput() as NFTMintOutput).getGroupID();\n\n  const mintTx = await avm.buildCreateNFTMintTx(\n    utxoSet,\n    owners,\n    sourceAddresses,\n    [changeAddress],\n    mintUtxo.getUTXOID(),\n    groupID,\n    payload\n  );\n  return mintTx;\n}\n\nexport async function buildEvmTransferNativeTx(\n  from: string,\n  to: string,\n  amount: BN, // in wei\n  gasPrice: BN,\n  gasLimit: number\n) {\n  const nonce = await web3.eth.getTransactionCount(from);\n  const chainId = await web3.eth.getChainId();\n  const networkId = await web3.eth.net.getId();\n  const chainParams = {\n    common: EthereumjsCommon.forCustomChain(\n      \"mainnet\",\n      { networkId, chainId },\n      \"istanbul\"\n    ),\n  };\n\n  const tx = new Transaction(\n    {\n      nonce: nonce,\n      gasPrice: gasPrice,\n      gasLimit: gasLimit,\n      to: to,\n      value: amount,\n      data: \"0x\",\n    },\n    chainParams\n  );\n  return tx;\n}\n\nexport async function buildEvmTransferErc20Tx(\n  from: string,\n  to: string,\n  amount: BN, // in wei\n  gasPrice: BN,\n  gasLimit: number,\n  token: Erc20Token\n) {\n  const nonce = await web3.eth.getTransactionCount(from);\n  const chainId = await web3.eth.getChainId();\n  const networkId = await web3.eth.net.getId();\n  const chainParams = {\n    common: EthereumjsCommon.forCustomChain(\n      \"mainnet\",\n      { networkId, chainId },\n      \"istanbul\"\n    ),\n  };\n\n  const tokenTx = token.createTransferTx(to, amount);\n\n  const tx = new Transaction(\n    {\n      nonce: nonce,\n      gasPrice: gasPrice,\n      gasLimit: gasLimit,\n      value: \"0x0\",\n      to: token.data.address,\n      data: tokenTx.encodeABI(),\n    },\n    chainParams\n  );\n  return tx;\n}\n\nexport async function buildEvmTransferErc721Tx(\n  from: string,\n  to: string,\n  gasPrice: BN,\n  gasLimit: number,\n  token: ERC721Token,\n  tokenId: string\n) {\n  const nonce = await web3.eth.getTransactionCount(from);\n  const chainId = await web3.eth.getChainId();\n  const networkId = await web3.eth.net.getId();\n  const chainParams = {\n    common: EthereumjsCommon.forCustomChain(\n      \"mainnet\",\n      { networkId, chainId },\n      \"istanbul\"\n    ),\n  };\n\n  const tokenTx = token.createTransferTx(from, to, tokenId);\n\n  const tx = new Transaction(\n    {\n      nonce: nonce,\n      gasPrice: gasPrice,\n      gasLimit: gasLimit,\n      value: \"0x0\",\n      to: token.data.address,\n      data: tokenTx.encodeABI(),\n    },\n    chainParams\n  );\n  return tx;\n}\n\nexport enum AvmTxNameEnum {\n  \"Transaction\" = AVMConstants.BASETX,\n  \"Mint\" = AVMConstants.CREATEASSETTX,\n  \"Operation\" = AVMConstants.OPERATIONTX,\n  \"Import\" = AVMConstants.IMPORTTX,\n  \"Export\" = AVMConstants.EXPORTTX,\n}\n\nexport enum PlatfromTxNameEnum {\n  \"Transaction\" = PlatformVMConstants.BASETX,\n  \"Add Validator\" = PlatformVMConstants.ADDVALIDATORTX,\n  \"Add Delegator\" = PlatformVMConstants.ADDDELEGATORTX,\n  \"Import\" = PlatformVMConstants.IMPORTTX,\n  \"Export\" = PlatformVMConstants.EXPORTTX,\n  \"Add Subnet Validator\" = PlatformVMConstants.ADDSUBNETVALIDATORTX,\n  \"Create Chain\" = PlatformVMConstants.CREATECHAINTX,\n  \"Create Subnet\" = PlatformVMConstants.CREATESUBNETTX,\n  \"Advance Time\" = PlatformVMConstants.ADVANCETIMETX,\n  \"Reward Validator\" = PlatformVMConstants.REWARDVALIDATORTX,\n}\n\n// TODO: create asset transactions\nexport enum ParseableAvmTxEnum {\n  \"Transaction\" = AVMConstants.BASETX,\n  \"Import\" = AVMConstants.IMPORTTX,\n  \"Export\" = AVMConstants.EXPORTTX,\n}\n\nexport enum ParseablePlatformEnum {\n  \"Transaction\" = PlatformVMConstants.BASETX,\n  \"Add Validator\" = PlatformVMConstants.ADDVALIDATORTX,\n  \"Add Delegator\" = PlatformVMConstants.ADDDELEGATORTX,\n  \"Import\" = PlatformVMConstants.IMPORTTX,\n  \"Export\" = PlatformVMConstants.EXPORTTX,\n}\n\nexport enum ParseableEvmTxEnum {\n  \"Import\" = EVMConstants.IMPORTTX,\n  \"Export\" = EVMConstants.EXPORTTX,\n}\n","import { Buffer } from \"buffer/\";\nimport createHash from \"create-hash\";\n\n/**\n * @ignore\n */\n\n/**\n * Helper utility for encryption and password hashing, browser-safe.\n * Encryption is using AES-GCM with a random public nonce.\n */\nexport default class CryptoHelpers {\n  protected ivSize: number = 12;\n\n  protected saltSize: number = 16;\n\n  protected tagLength: number = 128;\n\n  protected aesLength: number = 256;\n\n  public keygenIterations: number = 200000; //3.0, 2.0 uses 100000\n\n  /**\n   * Internal-intended function for cleaning passwords.\n   *\n   * @param password\n   * @param salt\n   */\n  _pwcleaner(password: string, slt: Buffer): Buffer {\n    const pw: Buffer = Buffer.from(password, \"utf8\");\n    return this.sha256(Buffer.concat([pw, slt]));\n  }\n  /**\n   * Internal-intended function for producing an intermediate key.\n   *\n   * @param pwkey\n   */\n\n  async _keyMaterial(pwkey: Buffer): Promise<CryptoKey> {\n    return window.crypto.subtle.importKey(\n      \"raw\",\n      new Uint8Array(pwkey),\n      { name: \"PBKDF2\" },\n      false,\n      [\"deriveKey\"]\n    );\n  }\n\n  /**\n   * Internal-intended function for turning an intermediate key into a salted key.\n   *\n   * @param keyMaterial\n   * @param salt\n   */\n  async _deriveKey(keyMaterial: CryptoKey, salt: Buffer): Promise<CryptoKey> {\n    return window.crypto.subtle.deriveKey(\n      {\n        name: \"PBKDF2\",\n        salt,\n        iterations: this.keygenIterations,\n        hash: \"SHA-256\",\n      },\n      keyMaterial,\n      { name: \"AES-GCM\", length: this.aesLength },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    );\n  }\n\n  /**\n   * A SHA256 helper function.\n   *\n   * @param message The message to hash\n   *\n   * @returns A {@link https://github.com/feross/buffer|Buffer} containing the SHA256 hash of the message\n   */\n  sha256(message: string | Buffer): Buffer {\n    let buff: Buffer;\n    if (typeof message === \"string\") {\n      buff = Buffer.from(message, \"utf8\");\n    } else {\n      buff = Buffer.from(message);\n    }\n    return Buffer.from(createHash(\"sha256\").update(buff).digest()); // ensures correct Buffer class is used\n  }\n\n  /**\n   * Generates a randomized {@link https://github.com/feross/buffer|Buffer} to be used as a salt\n   */\n  makeSalt(): Buffer {\n    const salt = Buffer.alloc(this.saltSize);\n    window.crypto.getRandomValues(salt);\n    return salt;\n  }\n\n  /**\n   * Produces a password-safe hash.\n   *\n   * @param password A string for the password\n   * @param salt An optional {@link https://github.com/feross/buffer|Buffer} containing a salt used in the password hash\n   *\n   * @returns An object containing the \"salt\" and the \"hash\" produced by this function, both as {@link https://github.com/feross/buffer|Buffer}.\n   */\n  async pwhash(\n    password: string,\n    salt: Buffer\n  ): Promise<{ salt: Buffer; hash: Buffer }> {\n    let slt: Buffer;\n    if (salt instanceof Buffer) {\n      slt = salt;\n      // @ts-ignore\n    } else if (salt instanceof Uint8Array && process.env.NODE_ENV === \"test\") {\n      slt = salt;\n    } else {\n      slt = this.makeSalt();\n    }\n\n    const hash: Buffer = this._pwcleaner(\n      password,\n      this._pwcleaner(password, slt)\n    );\n    return { salt: slt, hash };\n  }\n\n  /**\n   * Encrypts plaintext with the provided password using AES-GCM.\n   *\n   * @param password A string for the password\n   * @param plaintext The plaintext to encrypt\n   * @param salt An optional {@link https://github.com/feross/buffer|Buffer} for the salt to use in the encryption process\n   *\n   * @returns An object containing the \"salt\", \"iv\", and \"ciphertext\", all as {@link https://github.com/feross/buffer|Buffer}.\n   */\n  async encrypt(\n    password: string,\n    plaintext: Buffer | string,\n    salt: Buffer | undefined = undefined\n  ): Promise<{ salt: Buffer; iv: Buffer; ciphertext: Buffer }> {\n    let slt: Buffer;\n    if (typeof salt !== \"undefined\" && salt instanceof Buffer) {\n      slt = salt;\n    } else {\n      slt = this.makeSalt();\n    }\n\n    let pt: Buffer;\n    if (typeof plaintext !== \"undefined\" && plaintext instanceof Buffer) {\n      pt = plaintext;\n    } else {\n      pt = Buffer.from(plaintext, \"utf8\");\n    }\n    const pwkey: Buffer = this._pwcleaner(password, slt);\n    const keyMaterial: CryptoKey = await this._keyMaterial(pwkey);\n    const pkey: CryptoKey = await this._deriveKey(keyMaterial, slt);\n    const iv: Buffer = Buffer.from(\n      window.crypto.getRandomValues(new Uint8Array(this.ivSize))\n    );\n\n    const ciphertext: Buffer = Buffer.from(\n      await window.crypto.subtle.encrypt(\n        {\n          name: \"AES-GCM\",\n          iv,\n          additionalData: slt,\n          tagLength: this.tagLength,\n        },\n        pkey,\n        pt\n      )\n    );\n\n    return {\n      salt: slt,\n      iv,\n      ciphertext,\n    };\n  }\n\n  /**\n   * Decrypts ciphertext with the provided password, iv, and salt.\n   *\n   * @param password A string for the password\n   * @param ciphertext A {@link https://github.com/feross/buffer|Buffer} for the ciphertext\n   * @param salt A {@link https://github.com/feross/buffer|Buffer} for the salt\n   * @param iv A {@link https://github.com/feross/buffer|Buffer} for the iv\n   */\n  async decrypt(\n    password: string,\n    ciphertext: Buffer,\n    salt: Buffer,\n    iv: Buffer\n  ): Promise<Buffer> {\n    const pwkey: Buffer = this._pwcleaner(password, salt);\n    const keyMaterial: CryptoKey = await this._keyMaterial(pwkey);\n    const pkey: CryptoKey = await this._deriveKey(keyMaterial, salt);\n\n    const pt: Buffer = Buffer.from(\n      await window.crypto.subtle.decrypt(\n        {\n          name: \"AES-GCM\",\n          iv, // The initialization vector you used to encrypt\n          additionalData: salt, // The addtionalData you used to encrypt (if any)\n          tagLength: 128, // The tagLength you used to encrypt (if any)\n        },\n        pkey, // from generateKey or importKey above\n        ciphertext // ArrayBuffer of the data\n      )\n    );\n    return pt;\n  }\n\n  constructor() {}\n}\n","// Functions to manage import/export of keystore files\nimport {\n  AllKeyFileDecryptedTypes,\n  AllKeyFileTypes,\n  KeyFileDecryptedV2,\n  KeyFileDecryptedV3,\n  KeyFileDecryptedV4,\n  KeyFileDecryptedV5,\n  KeyFileDecryptedV6,\n  KeyFileKeyDecryptedV2,\n  KeyFileKeyDecryptedV3,\n  KeyFileKeyDecryptedV4,\n  KeyFileKeyDecryptedV5,\n  KeyFileKeyDecryptedV6,\n  KeyFileKeyV2,\n  KeyFileKeyV3,\n  KeyFileKeyV4,\n  KeyFileKeyV5,\n  KeyFileKeyV6,\n  KeyFileV2,\n  KeyFileV3,\n  KeyFileV4,\n  KeyFileV5,\n  KeyFileV6,\n  KeystoreFileKeyType,\n} from \"./IKeystore\";\nimport { avm, bintools } from \"@/AVA\";\nimport { Buffer } from \"buffer/\";\nimport MnemonicWallet from \"@/js/wallets/MnemonicWallet\";\nimport Crypto from \"@/js/Crypto\";\nimport { SingletonWallet } from \"@/js/wallets/SingletonWallet\";\nimport { AccessWalletMultipleInput } from \"@/store/types\";\nimport { keyToKeypair } from \"@/helpers/helper\";\nimport * as bip39 from \"bip39\";\nimport { Buffer as AjsBuffer } from \"avalanche\";\n\nconst cryptoHelpers = new Crypto();\n\nconst KEYSTORE_VERSION: string = \"6.0\";\n\nconst ITERATIONS_V2 = 100000;\nconst ITERATIONS_V3 = 200000; // and any version above\n\nconst SUPPORTED_VERSION = [\"2.0\", \"3.0\", \"4.0\", \"5.0\", \"6.0\"];\n\ninterface IHash {\n  salt: Buffer;\n  hash: Buffer;\n}\n\ninterface PKCrypt {\n  salt: Buffer;\n  iv: Buffer;\n  ciphertext: Buffer;\n}\n\nasync function readV2(data: KeyFileV2, pass: string) {\n  const version: string = data.version;\n  cryptoHelpers.keygenIterations = ITERATIONS_V2;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n  const pass_hash: string = data.pass_hash;\n\n  const checkHash: Buffer = await cryptoHelpers._pwcleaner(pass, salt);\n  const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash));\n\n  if (checkHashString !== pass_hash) {\n    throw \"INVALID_PASS\";\n  }\n\n  const keys: KeyFileKeyV2[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV2[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV2 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    const key_decrypt: Buffer = await cryptoHelpers.decrypt(\n      pass,\n      key,\n      salt,\n      nonce\n    );\n    const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt));\n\n    keysDecrypt.push({\n      key: key_string,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: keysDecrypt,\n  };\n}\nasync function readV3(data: KeyFileV3, pass: string) {\n  const version: string = data.version;\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n  const pass_hash: string = data.pass_hash;\n\n  const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt);\n  const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash));\n\n  if (checkHashString !== pass_hash) {\n    throw \"INVALID_PASS\";\n  }\n\n  const keys: KeyFileKeyV3[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV3[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV3 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    const key_decrypt: Buffer = await cryptoHelpers.decrypt(\n      pass,\n      key,\n      salt,\n      nonce\n    );\n    const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt));\n\n    keysDecrypt.push({\n      key: key_string,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: keysDecrypt,\n  };\n}\nasync function readV4(\n  data: KeyFileV4,\n  pass: string\n): Promise<KeyFileDecryptedV5> {\n  const version: string = data.version;\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n  const pass_hash: string = data.pass_hash;\n\n  const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt);\n  const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash));\n\n  if (checkHashString !== pass_hash) {\n    throw \"INVALID_PASS\";\n  }\n\n  const keys: KeyFileKeyV4[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV4[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV4 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    const key_decrypt: Buffer = await cryptoHelpers.decrypt(\n      pass,\n      key,\n      salt,\n      nonce\n    );\n    const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt));\n\n    keysDecrypt.push({\n      key: key_string,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: keysDecrypt,\n  };\n}\n\nasync function readV5(\n  data: KeyFileV5,\n  pass: string\n): Promise<KeyFileDecryptedV5> {\n  const version: string = data.version;\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n  const pass_hash = data.pass_hash;\n\n  const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt);\n  const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash));\n\n  if (checkHashString !== pass_hash) {\n    throw \"INVALID_PASS\";\n  }\n\n  const keys: KeyFileKeyV5[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV5[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV5 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    const key_decrypt: Buffer = await cryptoHelpers.decrypt(\n      pass,\n      key,\n      salt,\n      nonce\n    );\n    const key_string = key_decrypt.toString();\n\n    keysDecrypt.push({\n      key: key_string,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: keysDecrypt,\n  };\n}\n\nasync function readV6(\n  data: KeyFileV6,\n  pass: string\n): Promise<KeyFileDecryptedV6> {\n  const version: string = data.version;\n  const activeIndex = data.activeIndex;\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = bintools.cb58Decode(data.salt);\n\n  const keys: KeyFileKeyV6[] = data.keys;\n  const keysDecrypt: KeyFileKeyDecryptedV6[] = [];\n\n  for (let i: number = 0; i < keys.length; i++) {\n    const key_data: KeyFileKeyV6 = keys[i];\n\n    const key: Buffer = bintools.cb58Decode(key_data.key);\n    const type: KeystoreFileKeyType = key_data.type;\n    const nonce: Buffer = bintools.cb58Decode(key_data.iv);\n\n    let key_decrypt: Buffer;\n    try {\n      key_decrypt = await cryptoHelpers.decrypt(pass, key, salt, nonce);\n    } catch (e) {\n      throw \"INVALID_PASS\";\n    }\n\n    const key_string = key_decrypt.toString();\n\n    keysDecrypt.push({\n      key: key_string,\n      type: type,\n    });\n  }\n\n  return {\n    version,\n    activeIndex: activeIndex || 0,\n    keys: keysDecrypt,\n  };\n}\n\nasync function readKeyFile(\n  data: AllKeyFileTypes,\n  pass: string\n): Promise<AllKeyFileDecryptedTypes> {\n  switch (data.version) {\n    case \"6.0\":\n      return await readV6(data as KeyFileV6, pass);\n    case \"5.0\":\n      return await readV5(data as KeyFileV5, pass);\n    case \"4.0\":\n      return await readV4(data as KeyFileV4, pass);\n    case \"3.0\":\n      return await readV3(data as KeyFileV3, pass);\n    case \"2.0\":\n      return await readV2(data as KeyFileV2, pass);\n    default:\n      throw \"INVALID_VERSION\";\n  }\n}\n\nfunction extractKeysV2(\n  file: KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4\n): AccessWalletMultipleInput[] {\n  const chainID = avm.getBlockchainAlias();\n  const keys = (file as\n    | KeyFileDecryptedV2\n    | KeyFileDecryptedV3\n    | KeyFileDecryptedV4).keys;\n\n  return keys.map((key) => {\n    // Private keys from the keystore file do not have the PrivateKey- prefix\n    const pk = \"PrivateKey-\" + key.key;\n    const keypair = keyToKeypair(pk, chainID);\n\n    const keyBuf = keypair.getPrivateKey();\n    const keyHex: string = keyBuf.toString(\"hex\");\n    const paddedKeyHex = keyHex.padStart(64, \"0\");\n    const mnemonic: string = bip39.entropyToMnemonic(paddedKeyHex);\n\n    return {\n      key: mnemonic,\n      type: \"mnemonic\",\n    };\n  });\n}\n\nfunction extractKeysV5(file: KeyFileDecryptedV5): AccessWalletMultipleInput[] {\n  return file.keys.map((key) => ({\n    key: key.key,\n    type: \"mnemonic\",\n  }));\n}\n\nfunction extractKeysV6(file: KeyFileDecryptedV6): AccessWalletMultipleInput[] {\n  return file.keys.map((key) => ({\n    type: key.type,\n    key: key.key,\n  }));\n}\n\nfunction extractKeysFromDecryptedFile(\n  file: AllKeyFileDecryptedTypes\n): AccessWalletMultipleInput[] {\n  switch (file.version) {\n    case \"6.0\":\n      return extractKeysV6(file as KeyFileDecryptedV6);\n    case \"5.0\":\n      return extractKeysV5(file as KeyFileDecryptedV5);\n    case \"4.0\":\n      return extractKeysV2(file as KeyFileDecryptedV4);\n    case \"3.0\":\n      return extractKeysV2(file as KeyFileDecryptedV3);\n    case \"2.0\":\n      return extractKeysV2(file as KeyFileDecryptedV2);\n    default:\n      throw \"INVALID_VERSION\";\n  }\n}\n\n// Given an array of wallets and a password, return an encrypted JSON object that is the keystore file\nasync function makeKeyfile(\n  wallets: (MnemonicWallet | SingletonWallet)[],\n  pass: string,\n  activeIndex: number\n): Promise<KeyFileV6> {\n  // 3.0 and above uses 200,000\n  cryptoHelpers.keygenIterations = ITERATIONS_V3;\n\n  const salt: Buffer = await cryptoHelpers.makeSalt();\n\n  const keys: KeyFileKeyV6[] = [];\n\n  for (let i: number = 0; i < wallets.length; i++) {\n    const wallet = wallets[i];\n    let key;\n    let type: KeystoreFileKeyType;\n    if (wallet.type === \"singleton\") {\n      key = (wallet as SingletonWallet).key;\n      type = \"singleton\";\n    } else {\n      key = (wallet as MnemonicWallet).getMnemonic();\n      type = \"mnemonic\";\n    }\n    const pk_crypt: PKCrypt = await cryptoHelpers.encrypt(pass, key, salt);\n\n    const key_data: KeyFileKeyV6 = {\n      key: bintools.cb58Encode(AjsBuffer.from(pk_crypt.ciphertext)),\n      iv: bintools.cb58Encode(AjsBuffer.from(pk_crypt.iv)),\n      type: type,\n    };\n    keys.push(key_data);\n  }\n\n  const file_data: KeyFileV6 = {\n    version: KEYSTORE_VERSION,\n    salt: bintools.cb58Encode(AjsBuffer.from(salt)),\n    activeIndex,\n    keys: keys,\n  };\n  return file_data;\n}\n\nexport {\n  readKeyFile,\n  makeKeyfile,\n  KEYSTORE_VERSION,\n  extractKeysFromDecryptedFile,\n};\n","import {\n  KeyChain as AVMKeyChain,\n  KeyPair as AVMKeyPair,\n  UTXOSet as AVMUTXOSet,\n} from \"avalanche/dist/apis/avm\";\n\nimport { UTXOSet as PlatformUTXOSet } from \"avalanche/dist/apis/platformvm\";\nimport { getPreferredHRP } from \"avalanche/dist/utils\";\nimport { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport HDKey from \"hdkey\";\nimport { Buffer } from \"avalanche\";\nimport {\n  KeyChain as PlatformVMKeyChain,\n  KeyPair as PlatformVMKeyPair,\n} from \"avalanche/dist/apis/platformvm\";\nimport store from \"@/store\";\n\nimport { getAddressChains } from \"@/explorer_api\";\nimport { AvaNetwork } from \"@/js/AvaNetwork\";\nimport { ChainAlias } from \"./wallets/types\";\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from \"@/helpers/utxo_helper\";\nimport { updateFilterAddresses } from \"../providers\";\n\nconst INDEX_RANGE: number = 20; // a gap of at least 20 indexes is needed to claim an index unused\n\nconst SCAN_SIZE: number = 100; // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE; // How many items are actually scanned\nclass HdHelper {\n  chainId: ChainAlias;\n  keyChain: AVMKeyChain | PlatformVMKeyChain;\n  keyCache: {\n    [index: number]: AVMKeyPair | PlatformVMKeyPair;\n  };\n  addressCache: {\n    [index: number]: string;\n  };\n  hdCache: {\n    [index: number]: HDKey;\n  };\n  changePath: string;\n  masterKey: HDKey;\n  hdIndex: number;\n  utxoSet: AVMUTXOSet | PlatformUTXOSet;\n  isPublic: boolean;\n  isFetchUtxo: boolean; // true if updating balance\n  isInit: boolean; // true if HD index is found\n\n  constructor(\n    changePath: string,\n    masterKey: HDKey,\n    chainId: ChainAlias = \"X\",\n    isPublic: boolean = false\n  ) {\n    this.changePath = changePath;\n    this.isFetchUtxo = false;\n    this.isInit = false;\n\n    this.chainId = chainId;\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    if (chainId === \"X\") {\n      this.keyChain = new AVMKeyChain(hrp, chainId);\n      this.utxoSet = new AVMUTXOSet();\n    } else {\n      this.keyChain = new PlatformVMKeyChain(hrp, chainId);\n      this.utxoSet = new PlatformUTXOSet();\n    }\n\n    this.keyCache = {};\n    this.addressCache = {};\n    this.hdCache = {};\n    this.masterKey = masterKey;\n    this.hdIndex = 0;\n    this.isPublic = isPublic;\n    // this.oninit()\n  }\n\n  async oninit() {\n    await this.findHdIndex();\n  }\n\n  // When the wallet connects to a different network\n  // Clear internal data and scan again\n  async onNetworkChange() {\n    this.clearCache();\n    this.isInit = false;\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    if (this.chainId === \"X\") {\n      this.keyChain = new AVMKeyChain(hrp, this.chainId);\n      this.utxoSet = new AVMUTXOSet();\n    } else {\n      this.keyChain = new PlatformVMKeyChain(hrp, this.chainId);\n      this.utxoSet = new PlatformUTXOSet();\n    }\n    this.hdIndex = 0;\n    await this.oninit();\n  }\n\n  // Increments the hd index by one and adds the key\n  // returns the new keypair\n  incrementIndex(): number {\n    const newIndex: number = this.hdIndex + 1;\n\n    if (!this.isPublic) {\n      if (this.chainId === \"X\") {\n        const keychain = this.keyChain as AVMKeyChain;\n        const newKey = this.getKeyForIndex(newIndex) as AVMKeyPair;\n        keychain.addKey(newKey);\n      } else {\n        const keychain = this.keyChain as PlatformVMKeyChain;\n        const newKey = this.getKeyForIndex(newIndex) as PlatformVMKeyPair;\n        keychain.addKey(newKey);\n      }\n    }\n\n    this.hdIndex = newIndex;\n\n    // Update websocket addresses with the new one\n    updateFilterAddresses();\n\n    return newIndex;\n  }\n\n  async findHdIndex() {\n    // Check if explorer is available\n\n    // @ts-ignore\n    const network: AvaNetwork = store.state.Network.selectedNetwork;\n    const explorerUrl = network.explorerUrl;\n\n    if (explorerUrl) {\n      this.hdIndex = await this.findAvailableIndexExplorer();\n    } else {\n      this.hdIndex = await this.findAvailableIndexNode();\n    }\n\n    if (!this.isPublic) {\n      this.updateKeychain();\n    }\n    this.isInit = true;\n  }\n\n  // Fetches the utxos for the current keychain\n  // and increments the index if last index has a utxo\n  async updateUtxos(): Promise<AVMUTXOSet | PlatformUTXOSet> {\n    this.isFetchUtxo = true;\n\n    if (!this.isInit) {\n      console.error(\"HD Index not found yet.\");\n    }\n\n    const addrs: string[] = this.getAllDerivedAddresses();\n    let result: AVMUTXOSet | PlatformUTXOSet;\n\n    if (this.chainId === \"X\") {\n      result = await avmGetAllUTXOs(addrs);\n    } else {\n      result = await platformGetAllUTXOs(addrs);\n    }\n    this.utxoSet = result; // we can use local copy of utxos as cache for some functions\n\n    // If the hd index is full, increment\n    const currentAddr = this.getCurrentAddress();\n    const currentAddrBuf = bintools.parseAddress(currentAddr, this.chainId);\n    const currentUtxos = result.getUTXOIDs([currentAddrBuf]);\n\n    if (currentUtxos.length > 0) {\n      this.incrementIndex();\n    }\n    this.isFetchUtxo = false;\n    return result;\n  }\n\n  // Returns more addresses than the current index\n  getExtendedAddresses() {\n    const hdIndex = this.hdIndex;\n    return this.getAllDerivedAddresses(hdIndex + INDEX_RANGE);\n  }\n\n  // Not used?\n  getUtxos(): AVMUTXOSet | PlatformUTXOSet {\n    return this.utxoSet;\n  }\n\n  // Updates the helper keychain to contain keys upto the HD Index\n  updateKeychain(): AVMKeyChain | PlatformVMKeyChain {\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    let keychain: AVMKeyChain | PlatformVMKeyChain;\n\n    if (this.chainId === \"X\") {\n      keychain = new AVMKeyChain(hrp, this.chainId);\n    } else {\n      keychain = new PlatformVMKeyChain(hrp, this.chainId);\n    }\n\n    for (let i: number = 0; i <= this.hdIndex; i++) {\n      let key: AVMKeyPair | PlatformVMKeyPair;\n      if (this.chainId === \"X\") {\n        key = this.getKeyForIndex(i) as AVMKeyPair;\n        (keychain as AVMKeyChain).addKey(key);\n      } else {\n        key = this.getKeyForIndex(i) as PlatformVMKeyPair;\n        (keychain as PlatformVMKeyChain).addKey(key);\n      }\n    }\n    this.keyChain = keychain;\n    return keychain;\n  }\n\n  getKeychain() {\n    return this.keyChain;\n  }\n\n  // Returns all key pairs up to hd index\n  getAllDerivedKeys(upTo = this.hdIndex): AVMKeyPair[] | PlatformVMKeyPair[] {\n    const set: AVMKeyPair[] | PlatformVMKeyPair[] = [];\n    for (let i = 0; i <= upTo; i++) {\n      if (this.chainId === \"X\") {\n        const key = this.getKeyForIndex(i) as AVMKeyPair;\n        (set as AVMKeyPair[]).push(key);\n      } else {\n        const key = this.getKeyForIndex(i) as PlatformVMKeyPair;\n        (set as PlatformVMKeyPair[]).push(key);\n      }\n    }\n    return set;\n  }\n\n  getAllDerivedAddresses(upTo = this.hdIndex, start = 0): string[] {\n    const res = [];\n    for (let i = start; i <= upTo; i++) {\n      const addr = this.getAddressForIndex(i);\n      res.push(addr);\n    }\n    return res;\n  }\n\n  clearCache() {\n    this.keyCache = {};\n    this.addressCache = {};\n  }\n\n  // Scans the address space of this hd path and finds the last used index using the\n  // explorer API.\n  async findAvailableIndexExplorer(startIndex = 0): Promise<number> {\n    const upTo = 512;\n\n    const addrs = this.getAllDerivedAddresses(startIndex + upTo, startIndex);\n    const addrChains = await getAddressChains(addrs);\n\n    let chainID;\n    if (this.chainId === \"X\") {\n      chainID = avm.getBlockchainID();\n    } else {\n      chainID = pChain.getBlockchainID();\n    }\n\n    for (let i = 0; i < addrs.length - INDEX_RANGE; i++) {\n      let gapSize: number = 0;\n\n      for (let n = 0; n < INDEX_RANGE; n++) {\n        const scanIndex = i + n;\n        const scanAddr = addrs[scanIndex];\n\n        const rawAddr = scanAddr.split(\"-\")[1];\n        const chains: string[] = addrChains[rawAddr];\n        if (!chains) {\n          // If doesnt exist on any chain\n          gapSize++;\n        } else if (!chains.includes(chainID)) {\n          // If doesnt exist on this chain\n          gapSize++;\n        } else {\n          i = i + n;\n          break;\n        }\n      }\n\n      // If the gap is reached return the index\n      if (gapSize === INDEX_RANGE) {\n        return startIndex + i;\n      }\n    }\n\n    return await this.findAvailableIndexExplorer(\n      startIndex + (upTo - INDEX_RANGE)\n    );\n  }\n\n  // Uses the node to find last used HD index\n  // Only used when there is no explorer API available\n  async findAvailableIndexNode(start: number = 0): Promise<number> {\n    const addrs: string[] = [];\n\n    // Get keys for indexes start to start+scan_size\n    for (let i: number = start; i < start + SCAN_SIZE; i++) {\n      const address = this.getAddressForIndex(i);\n      addrs.push(address);\n    }\n\n    let utxoSet;\n\n    if (this.chainId === \"X\") {\n      utxoSet = (await avm.getUTXOs(addrs)).utxos;\n    } else {\n      utxoSet = (await pChain.getUTXOs(addrs)).utxos;\n    }\n\n    // Scan UTXOs of these indexes and try to find a gap of INDEX_RANGE\n    for (let i: number = 0; i < addrs.length - INDEX_RANGE; i++) {\n      let gapSize: number = 0;\n      // console.log(`Scan index: ${this.chainId} ${this.changePath}/${i+start}`);\n      for (let n: number = 0; n < INDEX_RANGE; n++) {\n        const scanIndex: number = i + n;\n        const addr: string = addrs[scanIndex];\n        const addrBuf = bintools.parseAddress(addr, this.chainId);\n        const addrUTXOs: string[] = utxoSet.getUTXOIDs([addrBuf]);\n        if (addrUTXOs.length === 0) {\n          gapSize++;\n        } else {\n          // Potential improvement\n          i = i + n;\n          break;\n        }\n      }\n\n      // If we found a gap of 20, we can return the last fullIndex+1\n      if (gapSize === INDEX_RANGE) {\n        const targetIndex = start + i;\n        return targetIndex;\n      }\n    }\n    return await this.findAvailableIndexNode(start + SCAN_RANGE);\n  }\n\n  getFirstAvailableIndex(): number {\n    for (let i = 0; i < this.hdIndex; i++) {\n      const addr = this.getAddressForIndex(i);\n      const addrBuf = bintools.parseAddress(addr, this.chainId);\n      const utxoIds = this.utxoSet.getUTXOIDs([addrBuf]);\n      if (utxoIds.length === 0) {\n        return i;\n      }\n    }\n\n    return 0;\n  }\n\n  // Returns the key of the first index that has no utxos\n  getFirstAvailableAddress(): string {\n    const idx = this.getFirstAvailableIndex();\n    return this.getAddressForIndex(idx);\n  }\n\n  getCurrentKey(): AVMKeyPair | PlatformVMKeyPair {\n    const index: number = this.hdIndex;\n    return this.getKeyForIndex(index);\n  }\n\n  getCurrentAddress(): string {\n    const index = this.hdIndex;\n    return this.getAddressForIndex(index);\n  }\n\n  // TODO: Public wallet should never be using this\n  getKeyForIndex(\n    index: number,\n    isPrivate: boolean = true\n  ): AVMKeyPair | PlatformVMKeyPair {\n    // If key is cached return that\n    let cacheExternal: AVMKeyPair | PlatformVMKeyPair;\n\n    if (this.chainId === \"X\") {\n      cacheExternal = this.keyCache[index] as AVMKeyPair;\n    } else {\n      cacheExternal = this.keyCache[index] as PlatformVMKeyPair;\n    }\n\n    if (cacheExternal) return cacheExternal;\n\n    const derivationPath: string = `${this.changePath}/${index.toString()}`;\n\n    // Get key from cache, if not generate it\n    let key: HDKey;\n    if (this.hdCache[index]) {\n      key = this.hdCache[index];\n    } else {\n      key = this.masterKey.derive(derivationPath) as HDKey;\n      this.hdCache[index] = key;\n    }\n\n    let pkHex: string;\n    if (!this.isPublic) {\n      pkHex = key.privateKey.toString(\"hex\");\n    } else {\n      pkHex = key.publicKey.toString(\"hex\");\n    }\n\n    const pkBuf: Buffer = new Buffer(pkHex, \"hex\");\n    const keypair = this.keyChain.importKey(pkBuf);\n\n    // save to cache\n    this.keyCache[index] = keypair;\n    return keypair;\n  }\n\n  getAddressForIndex(index: number): string {\n    if (this.addressCache[index]) {\n      return this.addressCache[index];\n    }\n\n    const derivationPath: string = `${this.changePath}/${index.toString()}`;\n    // let key: HDKey = this.masterKey.derive(derivationPath) as HDKey;\n\n    // Get key from cache, if not generate it\n    let key: HDKey;\n    if (this.hdCache[index]) {\n      key = this.hdCache[index];\n    } else {\n      key = this.masterKey.derive(derivationPath) as HDKey;\n      this.hdCache[index] = key;\n    }\n\n    const pkHex = key.publicKey.toString(\"hex\");\n    const pkBuff = Buffer.from(pkHex, \"hex\");\n    const hrp = getPreferredHRP(ava.getNetworkID());\n\n    const chainId = this.chainId;\n\n    // No need for PlatformKeypair because addressToString uses chainID to decode\n    const keypair = new AVMKeyPair(hrp, chainId);\n    const addrBuf = AVMKeyPair.addressFromPublicKey(pkBuff);\n    const addr = bintools.addressToString(hrp, chainId, addrBuf);\n\n    this.addressCache[index] = addr;\n    return addr;\n  }\n\n  // Given an address find the derived index\n  findAddressIndex(addr: string): number | null {\n    const addrs = this.getAllDerivedAddresses();\n    const index = addrs.indexOf(addr);\n\n    if (index < 0) return null;\n    return index;\n  }\n}\nexport { HdHelper };\n","import { ChainAlias } from \"@/js/wallets/types\";\nimport { UTXO } from \"avalanche/dist/apis/avm\";\n\nimport { BN, Buffer } from \"avalanche\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport { ava, avm, bintools, pChain } from \"@/AVA\";\nimport { UTXOSet as AVMUTXOSet } from \"avalanche/dist/apis/avm/utxos\";\nimport HDKey from \"hdkey\";\nimport { HdHelper } from \"@/js/HdHelper\";\nimport { UTXOSet as PlatformUTXOSet } from \"avalanche/dist/apis/platformvm/utxos\";\nimport {\n  buildCreateNftFamilyTx,\n  buildMintNftTx,\n  buildUnsignedTransaction,\n} from \"../TxHelper\";\nimport { WalletCore } from \"@/js/wallets/WalletCore\";\nimport { updateFilterAddresses } from \"../../providers\";\nimport { digestMessage } from \"@/helpers/helper\";\n\n// A base class other HD wallets are based on.\n// Mnemonic Wallet and LedgerWallet uses this\n\nabstract class HdWalletCore extends WalletCore {\n  chainId: string;\n\n  internalHelper: HdHelper;\n  externalHelper: HdHelper;\n  platformHelper: HdHelper;\n\n  ethHdNode: HDKey;\n  protected accountNodeXP: HDKey;\n\n  constructor(accountHdKey: HDKey, ethHdNode: HDKey, isPublic = true) {\n    super();\n    this.ethHdNode = ethHdNode;\n    this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID();\n    this.externalHelper = new HdHelper(\n      \"m/0\",\n      accountHdKey,\n      undefined,\n      isPublic\n    );\n    this.internalHelper = new HdHelper(\n      \"m/1\",\n      accountHdKey,\n      undefined,\n      isPublic\n    );\n    this.platformHelper = new HdHelper(\"m/0\", accountHdKey, \"P\", isPublic);\n    this.accountNodeXP = accountHdKey;\n\n    this.externalHelper.oninit().then((res) => {\n      this.updateInitState();\n    });\n    this.internalHelper.oninit().then((res) => {\n      this.updateInitState();\n    });\n    this.platformHelper.oninit().then((res) => {\n      this.updateInitState();\n    });\n  }\n\n  getXpubXP() {\n    return this.accountNodeXP.toJSON().xpub;\n  }\n\n  getEvmAddressBech(): string {\n    return bintools.addressToString(\n      ava.getHRP(),\n      \"C\",\n      // @ts-ignore\n      this.ethHdNode.pubKeyHash\n    );\n  }\n\n  updateAvmUTXOSet(): void {\n    // if (this.isFetchUtxos) return\n    const setExternal = this.externalHelper.utxoSet as AVMUTXOSet;\n    const setInternal = this.internalHelper.utxoSet as AVMUTXOSet;\n\n    const joined = setInternal.merge(setExternal);\n    this.utxoset = joined;\n  }\n\n  getFirstAvailableAddressPlatform(): string {\n    return this.platformHelper.getFirstAvailableAddress();\n  }\n\n  updateFetchState() {\n    this.isFetchUtxos =\n      this.externalHelper.isFetchUtxo ||\n      this.internalHelper.isFetchUtxo ||\n      this.platformHelper.isFetchUtxo;\n  }\n\n  updateInitState() {\n    this.isInit =\n      this.externalHelper.isInit &&\n      this.internalHelper.isInit &&\n      this.platformHelper.isInit;\n\n    if (this.isInit) {\n      updateFilterAddresses();\n    }\n  }\n  // Fetches the utxos\n  async getUTXOs(): Promise<void> {\n    this.updateUTXOsX();\n\n    // platform utxos are updated but not returned by function\n    this.updateUTXOsP();\n\n    return;\n  }\n\n  async updateUTXOsX() {\n    this.updateUTXOsExternal();\n    this.updateUTXOsInternal();\n  }\n\n  async updateUTXOsExternal() {\n    const res = await this.externalHelper.updateUtxos();\n    this.updateFetchState();\n    this.updateAvmUTXOSet();\n  }\n\n  async updateUTXOsInternal() {\n    const utxoSet = await this.internalHelper.updateUtxos();\n    this.updateFetchState();\n    this.updateAvmUTXOSet();\n  }\n\n  async updateUTXOsP() {\n    const utxoSet = await this.platformHelper.updateUtxos();\n    this.updateFetchState();\n  }\n\n  getAllDerivedExternalAddresses(): string[] {\n    return this.externalHelper.getAllDerivedAddresses();\n  }\n\n  getDerivedAddresses(): string[] {\n    const internal = this.internalHelper.getAllDerivedAddresses();\n    const external = this.externalHelper.getAllDerivedAddresses();\n    return internal.concat(external);\n  }\n\n  getDerivedAddressesP(): string[] {\n    return this.platformHelper.getAllDerivedAddresses();\n  }\n\n  getAllAddressesX() {\n    return this.getDerivedAddresses();\n  }\n\n  getAllAddressesP() {\n    return this.getDerivedAddressesP();\n  }\n  // Returns addresses to check for history\n  getHistoryAddresses(): string[] {\n    const internalIndex = this.internalHelper.hdIndex;\n    // They share the same address space, so whatever has the highest index\n    const externalIndex = Math.max(\n      this.externalHelper.hdIndex,\n      this.platformHelper.hdIndex\n    );\n\n    const internal = this.internalHelper.getAllDerivedAddresses(internalIndex);\n    const external = this.externalHelper.getAllDerivedAddresses(externalIndex);\n    return internal.concat(external);\n  }\n\n  getCurrentAddressAvm(): string {\n    return this.externalHelper.getCurrentAddress();\n  }\n\n  getChangeAddressAvm() {\n    return this.internalHelper.getCurrentAddress();\n  }\n\n  getChangeAddressPlatform() {\n    return this.platformHelper.getCurrentAddress();\n  }\n\n  getChangePath(chainId?: ChainAlias): string {\n    switch (chainId) {\n      case \"P\":\n        return this.platformHelper.changePath;\n      case \"X\":\n      default:\n        return this.internalHelper.changePath;\n    }\n  }\n\n  getChangeIndex(chainId?: ChainAlias): number {\n    switch (chainId) {\n      case \"P\":\n        return this.platformHelper.hdIndex;\n      case \"X\":\n      default:\n        return this.internalHelper.hdIndex;\n    }\n  }\n\n  getChangeFromIndex(idx?: number, chainId?: ChainAlias): string | null {\n    if (idx === undefined || idx === null) return null;\n\n    switch (chainId) {\n      case \"P\":\n        return this.platformHelper.getAddressForIndex(idx);\n      case \"X\":\n      default:\n        return this.internalHelper.getAddressForIndex(idx);\n    }\n  }\n\n  getPlatformRewardAddress(): string {\n    return this.platformHelper.getCurrentAddress();\n  }\n\n  getCurrentAddressPlatform(): string {\n    return this.platformHelper.getCurrentAddress();\n  }\n\n  getPlatformUTXOSet() {\n    return this.platformHelper.utxoSet as PlatformUTXOSet;\n  }\n\n  getPlatformActiveIndex() {\n    return this.platformHelper.hdIndex;\n  }\n\n  getExternalActiveIndex() {\n    return this.externalHelper.hdIndex;\n  }\n\n  getBaseAddress() {\n    return this.externalHelper.getAddressForIndex(0);\n  }\n\n  onnetworkchange(): void {\n    this.isInit = false;\n    this.stakeAmount = new BN(0);\n\n    this.externalHelper.onNetworkChange().then(() => {\n      this.updateInitState();\n    });\n    this.internalHelper.onNetworkChange().then(() => {\n      this.updateInitState();\n    });\n    this.platformHelper.onNetworkChange().then(() => {\n      this.updateInitState();\n    });\n\n    // TODO: Handle EVM changes\n  }\n\n  async buildUnsignedTransaction(\n    orders: (ITransaction | UTXO)[],\n    addr: string,\n    memo?: Buffer\n  ) {\n    const changeAddress = this.getChangeAddressAvm();\n    const derivedAddresses: string[] = this.getDerivedAddresses();\n    const utxoset = this.getUTXOSet();\n\n    return buildUnsignedTransaction(\n      orders,\n      addr,\n      derivedAddresses,\n      utxoset,\n      changeAddress,\n      memo\n    );\n  }\n\n  findExternalAddressIndex(address: string): number | null {\n    // TODO: Look for P addresses too\n    const indexX = this.externalHelper.findAddressIndex(address);\n    const indexP = this.platformHelper.findAddressIndex(address);\n\n    const index = indexX !== null ? indexX : indexP;\n\n    if (indexX === null && indexP === null)\n      throw new Error(\"Address not found.\");\n    return index;\n  }\n\n  async signMessageByExternalAddress(msgStr: string, address: string) {\n    const index = this.findExternalAddressIndex(address);\n    if (index === null) throw new Error(\"Address not found.\");\n    return await this.signMessageByExternalIndex(msgStr, index);\n  }\n\n  async signMessageByExternalIndex(\n    msgStr: string,\n    index: number\n  ): Promise<string> {\n    const digest = digestMessage(msgStr);\n\n    // Convert to the other Buffer and sign\n    const digestHex = digest.toString(\"hex\");\n    const digestBuff = Buffer.from(digestHex, \"hex\");\n\n    return await this.signHashByExternalIndex(index, digestBuff);\n  }\n\n  async signMessage(msg: string, address: string) {\n    return await this.signMessageByExternalAddress(msg, address);\n  }\n\n  abstract async signHashByExternalIndex(\n    index: number,\n    hash: Buffer\n  ): Promise<string>;\n}\nexport { HdWalletCore };\n","// import AppBtc from \"@ledgerhq/hw-app-btc\";\n//@ts-ignore\nimport AppDjtx from \"@obsidiansystems/hw-app-avalanche\";\n//@ts-ignore\nimport Eth from \"@ledgerhq/hw-app-eth\";\n\nimport EthereumjsCommon from \"@ethereumjs/common\";\nimport { Transaction } from \"@ethereumjs/tx\";\n\nimport moment from \"moment\";\nimport { Buffer, BN } from \"avalanche\";\nimport HDKey from \"hdkey\";\nimport { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nconst bippath = require(\"bip32-path\");\nimport createHash from \"create-hash\";\nimport store from \"@/store\";\nimport { importPublic, publicToAddress, bnToRlp, rlp } from \"ethereumjs-util\";\n\nimport {\n  UTXO as AVMUTXO,\n  UTXO,\n  UTXOSet as AVMUTXOSet,\n} from \"avalanche/dist/apis/avm/utxos\";\nimport { AvaWalletCore } from \"@/js/wallets/types\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport {\n  AVMConstants,\n  OperationTx,\n  SelectCredentialClass as AVMSelectCredentialClass,\n  TransferableOperation,\n  Tx as AVMTx,\n  UnsignedTx as AVMUnsignedTx,\n  ImportTx as AVMImportTx,\n} from \"avalanche/dist/apis/avm\";\n\nimport {\n  ImportTx as PlatformImportTx,\n  ExportTx as PlatformExportTx,\n  Tx as PlatformTx,\n  UTXO as PlatformUTXO,\n  UnsignedTx as PlatformUnsignedTx,\n  PlatformVMConstants,\n  SelectCredentialClass as PlatformSelectCredentialClass,\n  AddDelegatorTx,\n  AddValidatorTx,\n} from \"avalanche/dist/apis/platformvm\";\n\nimport {\n  UnsignedTx as EVMUnsignedTx,\n  ImportTx as EVMImportTx,\n  ExportTx as EVMExportTx,\n  Tx as EvmTx,\n  EVMConstants,\n  EVMInput,\n  SelectCredentialClass as EVMSelectCredentialClass,\n} from \"avalanche/dist/apis/evm\";\n\nimport {\n  Credential,\n  SigIdx,\n  Signature,\n  UTXOResponse,\n  Address,\n} from \"avalanche/dist/common\";\nimport { getPreferredHRP, PayloadBase } from \"avalanche/dist/utils\";\nimport { HdWalletCore } from \"@/js/wallets/HdWalletCore\";\nimport { ILedgerAppConfig } from \"@/store/types\";\nimport { WalletNameType } from \"@/js/wallets/types\";\nimport { abiDecoder, web3 } from \"@/evm\";\nimport {\n  AVA_ACCOUNT_PATH,\n  ETH_ACCOUNT_PATH,\n  LEDGER_ETH_ACCOUNT_PATH,\n} from \"./MnemonicWallet\";\nimport { ChainIdType } from \"@/constants\";\nimport {\n  ParseableAvmTxEnum,\n  ParseablePlatformEnum,\n  ParseableEvmTxEnum,\n} from \"../TxHelper\";\nimport { ILedgerBlockMessage } from \"../../store/modules/ledger/types\";\nimport Erc20Token from \"@/js/Erc20Token\";\nimport { WalletHelper } from \"@/helpers/wallet_helper\";\nimport { bnToBig, idToChainAlias } from \"@avalabs/avalanche-wallet-sdk\";\n\nexport const MIN_EVM_SUPPORT_V = \"0.5.3\";\n\nclass LedgerWallet extends HdWalletCore implements AvaWalletCore {\n  app: AppDjtx;\n  ethApp: Eth;\n  type: WalletNameType;\n\n  ethAddress: string;\n  ethBalance: BN;\n  config: ILedgerAppConfig;\n  ethHdNode: HDKey;\n\n  constructor(\n    app: AppDjtx,\n    hdkey: HDKey,\n    config: ILedgerAppConfig,\n    hdEth: HDKey,\n    ethApp: Eth\n  ) {\n    super(hdkey, hdEth);\n    this.app = app;\n    this.ethApp = ethApp;\n    this.type = \"ledger\";\n    this.config = config;\n    this.ethHdNode = hdEth;\n\n    if (hdEth) {\n      const ethKey = hdEth;\n      const ethPublic = importPublic(ethKey.publicKey);\n      this.ethAddress = publicToAddress(ethPublic).toString(\"hex\");\n      this.ethBalance = new BN(0);\n    } else {\n      this.ethAddress = \"\";\n      this.ethBalance = new BN(0);\n    }\n  }\n\n  static async fromApp(app: AppDjtx, eth: Eth, config: ILedgerAppConfig) {\n    const res = await app.getWalletExtendedPublicKey(AVA_ACCOUNT_PATH);\n\n    const hd = new HDKey();\n    hd.publicKey = res.public_key;\n    hd.chainCode = res.chain_code;\n\n    const ethRes = await eth.getAddress(LEDGER_ETH_ACCOUNT_PATH, true, true);\n    const hdEth = new HDKey();\n    // @ts-ignore\n    hdEth.publicKey = Buffer.from(ethRes.publicKey, \"hex\");\n    // @ts-ignore\n    hdEth.chainCode = Buffer.from(ethRes.chainCode, \"hex\");\n\n    return new LedgerWallet(app, hd, config, hdEth, eth);\n  }\n\n  // Returns an array of derivation paths that need to sign this transaction\n  // Used with signTransactionHash and signTransactionParsable\n  getTransactionPaths<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n    unsignedTx: UnsignedTx,\n    chainId: ChainIdType\n  ): { paths: string[]; isDjtxOnly: boolean } {\n    // TODO: This is a nasty fix. Remove when AJS is updated.\n    unsignedTx.toBuffer();\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n\n    const ins = tx.getIns();\n    let operations: TransferableOperation[] = [];\n\n    // Try to get operations, it will fail if there are none, ignore and continue\n    try {\n      operations = (tx as OperationTx).getOperations();\n    } catch (e) {\n      console.log(e);\n    }\n\n    let items = ins;\n    if (\n      (txType === AVMConstants.IMPORTTX && chainId === \"X\") ||\n      (txType === PlatformVMConstants.IMPORTTX && chainId === \"P\")\n    ) {\n      items = ((tx as AVMImportTx) || PlatformImportTx).getImportInputs();\n    }\n\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    const paths: string[] = [];\n\n    let isDjtxOnly = true;\n\n    // Collect derivation paths for source addresses\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n\n      const assetId = bintools.cb58Encode(item.getAssetID());\n      // @ts-ignore\n      if (assetId !== store.state.Assets.AVA_ASSET_ID) {\n        isDjtxOnly = false;\n      }\n\n      const sigidxs: SigIdx[] = item.getInput().getSigIdxs();\n      const sources = sigidxs.map((sigidx) => sigidx.getSource());\n      const addrs: string[] = sources.map((source) => {\n        return bintools.addressToString(hrp, chainId, source);\n      });\n\n      for (let j = 0; j < addrs.length; j++) {\n        const srcAddr = addrs[j];\n        const pathStr = this.getPathFromAddress(srcAddr); // returns change/index\n\n        paths.push(pathStr);\n      }\n    }\n\n    // Do the Same for operational inputs, if there are any...\n    for (let i = 0; i < operations.length; i++) {\n      const op = operations[i];\n      const sigidxs: SigIdx[] = op.getOperation().getSigIdxs();\n      const sources = sigidxs.map((sigidx) => sigidx.getSource());\n      const addrs: string[] = sources.map((source) => {\n        return bintools.addressToString(hrp, chainId, source);\n      });\n\n      for (let j = 0; j < addrs.length; j++) {\n        const srcAddr = addrs[j];\n        const pathStr = this.getPathFromAddress(srcAddr); // returns change/index\n\n        paths.push(pathStr);\n      }\n    }\n\n    return { paths, isDjtxOnly };\n  }\n\n  pathsToUniqueBipPaths(paths: string[]) {\n    const uniquePaths = paths.filter((val: any, i: number) => {\n      return paths.indexOf(val) === i;\n    });\n\n    const bip32Paths = uniquePaths.map((path) => {\n      return bippath.fromString(path, false);\n    });\n\n    return bip32Paths;\n  }\n\n  getChangeBipPath<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(unsignedTx: UnsignedTx, chainId: ChainIdType) {\n    if (chainId === \"C\") {\n      return null;\n    }\n\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n\n    const chainChangePath = this.getChangePath(chainId).split(\"m/\")[1];\n    let changeIdx = this.getChangeIndex(chainId);\n    // If change and destination paths are the same\n    // it can cause ledger to not display the destination amt.\n    // Since platform helper does not have internal/external\n    // path for change (it uses the next address)\n    // there can be an address collisions.\n    if (\n      (txType === PlatformVMConstants.IMPORTTX ||\n        txType === PlatformVMConstants.EXPORTTX) &&\n      this.platformHelper.hdIndex === this.externalHelper.hdIndex\n    ) {\n      return null;\n    } else if (\n      txType === PlatformVMConstants.ADDVALIDATORTX ||\n      txType === PlatformVMConstants.ADDDELEGATORTX\n    ) {\n      changeIdx = this.platformHelper.getFirstAvailableIndex();\n    }\n\n    return bippath.fromString(\n      `${AVA_ACCOUNT_PATH}/${chainChangePath}/${changeIdx}`\n    );\n  }\n\n  getCredentials<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(\n    unsignedTx: UnsignedTx,\n    paths: string[],\n    sigMap: any,\n    chainId: ChainIdType\n  ): Credential[] {\n    const creds: Credential[] = [];\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n\n    // @ts-ignore\n    const ins = tx.getIns ? tx.getIns() : [];\n    let operations: TransferableOperation[] = [];\n    let evmInputs: EVMInput[] = [];\n\n    let items = ins;\n    if (\n      (txType === AVMConstants.IMPORTTX && chainId === \"X\") ||\n      (txType === PlatformVMConstants.IMPORTTX && chainId === \"P\") ||\n      (txType === EVMConstants.IMPORTTX && chainId === \"C\")\n    ) {\n      items = (\n        (tx as AVMImportTx) ||\n        PlatformImportTx ||\n        EVMImportTx\n      ).getImportInputs();\n    }\n\n    // Try to get operations, it will fail if there are none, ignore and continue\n    try {\n      operations = (tx as OperationTx).getOperations();\n    } catch (e) {\n      console.error(e);\n    }\n\n    let CredentialClass;\n    if (chainId === \"X\") {\n      CredentialClass = AVMSelectCredentialClass;\n    } else if (chainId === \"P\") {\n      CredentialClass = PlatformSelectCredentialClass;\n    } else {\n      CredentialClass = EVMSelectCredentialClass;\n    }\n\n    // Try to get evm inputs, it will fail if there are none, ignore and continue\n    try {\n      evmInputs = (tx as EVMExportTx).getInputs();\n    } catch (e) {\n      console.error(e);\n    }\n\n    for (let i = 0; i < items.length; i++) {\n      const sigidxs: SigIdx[] = items[i].getInput().getSigIdxs();\n      const cred: Credential = CredentialClass(\n        items[i].getInput().getCredentialID()\n      );\n\n      for (let j = 0; j < sigidxs.length; j++) {\n        const pathIndex = i + j;\n        const pathStr = paths[pathIndex];\n\n        const sigRaw = sigMap.get(pathStr);\n        const sigBuff = Buffer.from(sigRaw);\n        const sig: Signature = new Signature();\n        sig.fromBuffer(sigBuff);\n        cred.addSignature(sig);\n      }\n      creds.push(cred);\n    }\n\n    for (let i = 0; i < operations.length; i++) {\n      const op = operations[i].getOperation();\n      const sigidxs: SigIdx[] = op.getSigIdxs();\n      const cred: Credential = CredentialClass(op.getCredentialID());\n\n      for (let j = 0; j < sigidxs.length; j++) {\n        const pathIndex = items.length + i + j;\n        const pathStr = paths[pathIndex];\n\n        const sigRaw = sigMap.get(pathStr);\n        const sigBuff = Buffer.from(sigRaw);\n        const sig: Signature = new Signature();\n        sig.fromBuffer(sigBuff);\n        cred.addSignature(sig);\n      }\n      creds.push(cred);\n    }\n\n    for (let i = 0; i < evmInputs.length; i++) {\n      const evmInput = evmInputs[i];\n      const sigidxs: SigIdx[] = evmInput.getSigIdxs();\n      const cred: Credential = CredentialClass(evmInput.getCredentialID());\n\n      for (let j = 0; j < sigidxs.length; j++) {\n        const pathIndex = items.length + i + j;\n        const pathStr = paths[pathIndex];\n\n        const sigRaw = sigMap.get(pathStr);\n        const sigBuff = Buffer.from(sigRaw);\n        const sig: Signature = new Signature();\n        sig.fromBuffer(sigBuff);\n        cred.addSignature(sig);\n      }\n      creds.push(cred);\n    }\n\n    return creds;\n  }\n\n  // Used for non parsable transactions.\n  // Ideally we wont use this function at all, but ledger is not ready yet.\n  async signTransactionHash<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n    SignedTx extends AVMTx | PlatformTx | EvmTx\n  >(\n    unsignedTx: UnsignedTx,\n    paths: string[],\n    chainId: ChainIdType\n  ): Promise<SignedTx> {\n    const txbuff = unsignedTx.toBuffer();\n    const msg: Buffer = Buffer.from(\n      createHash(\"sha256\").update(txbuff).digest()\n    );\n\n    try {\n      store.commit(\"Ledger/openModal\", {\n        title: \"Sign Hash\",\n        messages: [],\n        info: msg.toString(\"hex\").toUpperCase(),\n      });\n\n      const bip32Paths = this.pathsToUniqueBipPaths(paths);\n\n      // Sign the msg with ledger\n      const accountPathSource =\n        chainId === \"C\" ? ETH_ACCOUNT_PATH : AVA_ACCOUNT_PATH;\n      const accountPath = bippath.fromString(`${accountPathSource}`);\n      const sigMap = await this.app.signHash(accountPath, bip32Paths, msg);\n      store.commit(\"Ledger/closeModal\");\n\n      const creds: Credential[] = this.getCredentials<UnsignedTx>(\n        unsignedTx,\n        paths,\n        sigMap,\n        chainId\n      );\n\n      let signedTx;\n      switch (chainId) {\n        case \"X\":\n          signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds);\n          break;\n        case \"P\":\n          signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds);\n          break;\n        case \"C\":\n          signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds);\n          break;\n      }\n\n      return signedTx as SignedTx;\n    } catch (e) {\n      store.commit(\"Ledger/closeModal\");\n      console.error(e);\n      throw e;\n    }\n  }\n\n  // Used for signing transactions that are parsable\n  async signTransactionParsable<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n    SignedTx extends AVMTx | PlatformTx | EvmTx\n  >(\n    unsignedTx: UnsignedTx,\n    paths: string[],\n    chainId: ChainIdType\n  ): Promise<SignedTx> {\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n    const parseableTxs = {\n      X: ParseableAvmTxEnum,\n      P: ParseablePlatformEnum,\n      C: ParseableEvmTxEnum,\n    }[chainId];\n\n    const title = `Sign ${parseableTxs[txType]}`;\n\n    const bip32Paths = this.pathsToUniqueBipPaths(paths);\n\n    const accountPath =\n      chainId === \"C\"\n        ? bippath.fromString(`${ETH_ACCOUNT_PATH}`)\n        : bippath.fromString(`${AVA_ACCOUNT_PATH}`);\n    const txbuff = unsignedTx.toBuffer();\n    const changePath = this.getChangeBipPath(unsignedTx, chainId);\n    const messages = this.getTransactionMessages<UnsignedTx>(\n      unsignedTx,\n      chainId,\n      changePath\n    );\n\n    try {\n      store.commit(\"Ledger/openModal\", {\n        title: title,\n        messages: messages,\n        info: null,\n      });\n\n      const ledgerSignedTx = await this.app.signTransaction(\n        accountPath,\n        bip32Paths,\n        txbuff,\n        changePath\n      );\n\n      const sigMap = ledgerSignedTx.signatures;\n      const creds = this.getCredentials<UnsignedTx>(\n        unsignedTx,\n        paths,\n        sigMap,\n        chainId\n      );\n\n      let signedTx;\n      switch (chainId) {\n        case \"X\":\n          signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds);\n          break;\n        case \"P\":\n          signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds);\n          break;\n        case \"C\":\n          signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds);\n          break;\n      }\n\n      return signedTx as SignedTx;\n    } catch (e) {\n      store.commit(\"Ledger/closeModal\");\n      console.error(e);\n      throw e;\n    }\n  }\n\n  getOutputMsgs<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(\n    unsignedTx: UnsignedTx,\n    chainId: ChainIdType,\n    changePath: null | { toPathArray: () => number[] }\n  ): ILedgerBlockMessage[] {\n    const messages: ILedgerBlockMessage[] = [];\n    const hrp = getPreferredHRP(ava.getNetworkID());\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n\n    // @ts-ignore\n    let outs;\n    if (\n      (txType === AVMConstants.EXPORTTX && chainId === \"X\") ||\n      (txType === PlatformVMConstants.EXPORTTX && chainId === \"P\")\n    ) {\n      outs = (tx as PlatformExportTx).getExportOutputs();\n    } else if (txType === EVMConstants.EXPORTTX && chainId === \"C\") {\n      outs = (tx as EVMExportTx).getExportedOutputs();\n    } else {\n      outs = (tx as PlatformExportTx).getOuts();\n    }\n\n    let destinationChain = chainId;\n    if (chainId === \"C\" && txType === EVMConstants.EXPORTTX)\n      destinationChain = \"X\";\n\n    if (destinationChain === \"C\") {\n      for (let i = 0; i < outs.length; i++) {\n        // @ts-ignore\n        const value = outs[i].getAddress();\n        const addr = bintools.addressToString(hrp, chainId, value);\n        // @ts-ignore\n        const amt = bnToBig(outs[i].getAmount(), 9);\n\n        messages.push({\n          title: \"Output\",\n          value: `${addr} - ${amt.toString()} DJTX`,\n        });\n      }\n    } else {\n      const changeIdx = changePath?.toPathArray()[\n        changePath?.toPathArray().length - 1\n      ];\n      const changeAddr = this.getChangeFromIndex(changeIdx, destinationChain);\n\n      for (let i = 0; i < outs.length; i++) {\n        outs[i]\n          .getOutput()\n          .getAddresses()\n          .forEach((value) => {\n            const addr = bintools.addressToString(hrp, chainId, value);\n            // @ts-ignore\n            const amt = bnToBig(outs[i].getOutput().getAmount(), 9);\n\n            if (!changePath || changeAddr !== addr)\n              messages.push({\n                title: \"Output\",\n                value: `${addr} - ${amt.toString()} DJTX`,\n              });\n          });\n      }\n    }\n\n    return messages;\n  }\n\n  getValidateDelegateMsgs<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx\n  >(unsignedTx: UnsignedTx, chainId: ChainIdType): ILedgerBlockMessage[] {\n    const tx =\n      ((unsignedTx as\n        | AVMUnsignedTx\n        | PlatformUnsignedTx).getTransaction() as AddValidatorTx) ||\n      AddDelegatorTx;\n    const txType = tx.getTxType();\n    const messages: ILedgerBlockMessage[] = [];\n\n    if (\n      (txType === PlatformVMConstants.ADDDELEGATORTX && chainId === \"P\") ||\n      (txType === PlatformVMConstants.ADDVALIDATORTX && chainId === \"P\")\n    ) {\n      const format = \"YYYY-MM-DD H:mm:ss UTC\";\n\n      const nodeID = bintools.cb58Encode(tx.getNodeID());\n      const startTime = moment(tx.getStartTime().toNumber() * 1000)\n        .utc()\n        .format(format);\n\n      const endTime = moment(tx.getEndTime().toNumber() * 1000)\n        .utc()\n        .format(format);\n\n      const stakeAmt = bnToBig(tx.getStakeAmount(), 9);\n\n      const rewardOwners = tx.getRewardOwners();\n      const hrp = ava.getHRP();\n      const rewardAddrs = rewardOwners\n        .getOutput()\n        .getAddresses()\n        .map((addr) => {\n          return bintools.addressToString(hrp, chainId, addr);\n        });\n\n      messages.push({ title: \"NodeID\", value: nodeID });\n      messages.push({ title: \"Start Time\", value: startTime });\n      messages.push({ title: \"End Time\", value: endTime });\n      messages.push({ title: \"Total Stake\", value: `${stakeAmt} DJTX` });\n      messages.push({\n        title: \"Stake\",\n        value: `${stakeAmt} to ${this.platformHelper.getCurrentAddress()}`,\n      });\n      messages.push({\n        title: \"Reward to\",\n        value: `${rewardAddrs.join(\"\\n\")}`,\n      });\n      // @ts-ignore\n      if (tx.delegationFee) {\n        // @ts-ignore\n        messages.push({\n          title: \"Delegation Fee\",\n          //@ts-ignore\n          value: `${tx.delegationFee}%`,\n        });\n      }\n      messages.push({ title: \"Fee\", value: \"0\" });\n    }\n\n    return messages;\n  }\n\n  getFeeMsgs<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(unsignedTx: UnsignedTx, chainId: ChainIdType): ILedgerBlockMessage[] {\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n    const messages = [];\n\n    if (\n      (txType === AVMConstants.BASETX && chainId === \"X\") ||\n      (txType === AVMConstants.EXPORTTX && chainId === \"X\") ||\n      (txType === AVMConstants.IMPORTTX && chainId === \"X\") ||\n      (txType === PlatformVMConstants.EXPORTTX && chainId === \"P\") ||\n      (txType === PlatformVMConstants.IMPORTTX && chainId === \"P\") ||\n      (txType === EVMConstants.EXPORTTX && chainId === \"C\") ||\n      (txType === EVMConstants.IMPORTTX && chainId === \"C\")\n    ) {\n      messages.push({ title: \"Fee\", value: `${0.001} DJTX` });\n    }\n\n    return messages;\n  }\n\n  // Given the unsigned transaction returns an array of messages that will be displayed on ledgegr window\n  getTransactionMessages<\n    UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx\n  >(\n    unsignedTx: UnsignedTx,\n    chainId: ChainIdType,\n    changePath: null | { toPathArray: () => number[] }\n  ): ILedgerBlockMessage[] {\n    const messages: ILedgerBlockMessage[] = [];\n\n    const outputMessages = this.getOutputMsgs(unsignedTx, chainId, changePath);\n    //@ts-ignore\n    messages.push(...outputMessages);\n\n    const validateDelegateMessages = this.getValidateDelegateMsgs(\n      unsignedTx as AVMUnsignedTx | PlatformUnsignedTx,\n      chainId\n    );\n    messages.push(...validateDelegateMessages);\n\n    const feeMessages = this.getFeeMsgs(unsignedTx, chainId);\n    messages.push(...feeMessages);\n\n    return messages;\n  }\n\n  getEvmTransactionMessages(tx: Transaction): ILedgerBlockMessage[] {\n    const gasPrice = tx.gasPrice;\n    const gasLimit = tx.gasLimit;\n    const totFee = gasPrice.mul(new BN(gasLimit));\n    const feeNano = bnToBig(totFee, 9);\n\n    let msgs: ILedgerBlockMessage[] = [];\n    try {\n      const test = \"0x\" + tx.data.toString(\"hex\");\n      const data = abiDecoder.decodeMethod(test);\n\n      const callMsg: ILedgerBlockMessage = {\n        title: \"Contract Call\",\n        value: data.name,\n      };\n      const paramMsgs: ILedgerBlockMessage[] = data.params.map((param: any) => {\n        return {\n          title: param.name,\n          value: param.value,\n        };\n      });\n\n      const feeMsg: ILedgerBlockMessage = {\n        title: \"Fee\",\n        value: feeNano.toLocaleString() + \" nDJTX\",\n      };\n\n      msgs = [callMsg, ...paramMsgs, feeMsg];\n    } catch (e) {\n      console.log(e);\n    }\n    return msgs;\n  }\n\n  async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n    const chainId: ChainIdType = \"X\";\n\n    const parseableTxs = ParseableAvmTxEnum;\n    const { paths, isDjtxOnly } = this.getTransactionPaths<AVMUnsignedTx>(\n      unsignedTx,\n      chainId\n    );\n\n    // If ledger doesnt support parsing, sign hash\n    const canLedgerParse = this.config.version >= \"0.3.1\";\n    const isParsableType = txType in parseableTxs && isDjtxOnly;\n\n    let signedTx;\n    if (canLedgerParse && isParsableType) {\n      signedTx = await this.signTransactionParsable<AVMUnsignedTx, AVMTx>(\n        unsignedTx,\n        paths,\n        chainId\n      );\n    } else {\n      signedTx = await this.signTransactionHash<AVMUnsignedTx, AVMTx>(\n        unsignedTx,\n        paths,\n        chainId\n      );\n    }\n\n    store.commit(\"Ledger/closeModal\");\n    return signedTx;\n  }\n\n  async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n    const tx = unsignedTx.getTransaction();\n    const txType = tx.getTxType();\n    const chainId: ChainIdType = \"P\";\n    const parseableTxs = ParseablePlatformEnum;\n\n    const { paths, isDjtxOnly } = this.getTransactionPaths<PlatformUnsignedTx>(\n      unsignedTx,\n      chainId\n    );\n    // If ledger doesnt support parsing, sign hash\n    let canLedgerParse = this.config.version >= \"0.3.1\";\n    const isParsableType = txType in parseableTxs && isDjtxOnly;\n\n    // TODO: Remove after ledger is fixed\n    // If UTXOS contain lockedStakeable funds always use sign hash\n    const txIns = unsignedTx.getTransaction().getIns();\n    for (let i = 0; i < txIns.length; i++) {\n      const typeID = txIns[i].getInput().getTypeID();\n      if (typeID === PlatformVMConstants.STAKEABLELOCKINID) {\n        canLedgerParse = false;\n        break;\n      }\n    }\n\n    // TODO: Remove after ledger update\n    // Ledger is not able to parse P/C atomic transactions\n    if (txType === PlatformVMConstants.EXPORTTX) {\n      const destChainBuff = (tx as PlatformExportTx).getDestinationChain();\n      // If destination chain is C chain, sign hash\n      const destChain = idToChainAlias(bintools.cb58Encode(destChainBuff));\n      if (destChain === \"C\") {\n        canLedgerParse = false;\n      }\n    }\n    // TODO: Remove after ledger update\n    if (txType === PlatformVMConstants.IMPORTTX) {\n      const sourceChainBuff = (tx as PlatformImportTx).getSourceChain();\n      // If destination chain is C chain, sign hash\n      const sourceChain = idToChainAlias(bintools.cb58Encode(sourceChainBuff));\n      if (sourceChain === \"C\") {\n        canLedgerParse = false;\n      }\n    }\n\n    let signedTx;\n    if (canLedgerParse && isParsableType) {\n      signedTx = await this.signTransactionParsable<\n        PlatformUnsignedTx,\n        PlatformTx\n      >(unsignedTx, paths, chainId);\n    } else {\n      signedTx = await this.signTransactionHash<PlatformUnsignedTx, PlatformTx>(\n        unsignedTx,\n        paths,\n        chainId\n      );\n    }\n    store.commit(\"Ledger/closeModal\");\n    return signedTx;\n  }\n\n  async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n    // TODO: Might need to upgrade paths array to:\n    //  paths = Array(utxoSet.getAllUTXOs().length).fill('0/0'),\n    const tx = unsignedTx.getTransaction();\n    const typeId = tx.getTxType();\n\n    let canLedgerParse = true;\n\n    let paths = [\"0/0\"];\n    if (typeId === EVMConstants.EXPORTTX) {\n      const ins = (tx as EVMExportTx).getInputs();\n      paths = ins.map((input) => \"0/0\");\n    } else if (typeId === EVMConstants.IMPORTTX) {\n      const ins = (tx as EVMImportTx).getImportInputs();\n      paths = ins.map((input) => \"0/0\");\n    }\n\n    // TODO: Remove after ledger update\n    // Ledger is not able to parse P/C atomic transactions\n    if (typeId === EVMConstants.EXPORTTX) {\n      const destChainBuff = (tx as EVMExportTx).getDestinationChain();\n      // If destination chain is C chain, sign hash\n      const destChain = idToChainAlias(bintools.cb58Encode(destChainBuff));\n      if (destChain === \"P\") {\n        canLedgerParse = false;\n      }\n    }\n    // TODO: Remove after ledger update\n    if (typeId === EVMConstants.IMPORTTX) {\n      const sourceChainBuff = (tx as EVMImportTx).getSourceChain();\n      // If destination chain is C chain, sign hash\n      const sourceChain = idToChainAlias(bintools.cb58Encode(sourceChainBuff));\n      if (sourceChain === \"P\") {\n        canLedgerParse = false;\n      }\n    }\n\n    let txSigned;\n    if (canLedgerParse) {\n      txSigned = (await this.signTransactionParsable(\n        unsignedTx,\n        paths,\n        \"C\"\n      )) as EvmTx;\n    } else {\n      txSigned = (await this.signTransactionHash(\n        unsignedTx,\n        paths,\n        \"C\"\n      )) as EvmTx;\n    }\n    store.commit(\"Ledger/closeModal\");\n    return txSigned;\n  }\n\n  async signEvm(tx: Transaction) {\n    const rawUnsignedTx = rlp.encode([\n      bnToRlp(tx.nonce),\n      bnToRlp(tx.gasPrice),\n      bnToRlp(tx.gasLimit),\n      tx.to !== undefined ? tx.to.buf : Buffer.from([]),\n      bnToRlp(tx.value),\n      tx.data,\n      bnToRlp(new BN(tx.getChainId())),\n      Buffer.from([]),\n      Buffer.from([]),\n    ]);\n\n    try {\n      const msgs = this.getEvmTransactionMessages(tx);\n\n      // Open Modal Prompt\n      store.commit(\"Ledger/openModal\", {\n        title: \"Transfer\",\n        messages: msgs,\n        info: null,\n      });\n      const signature = await this.ethApp.signTransaction(\n        LEDGER_ETH_ACCOUNT_PATH,\n        rawUnsignedTx.toString(\"hex\")\n      );\n      store.commit(\"Ledger/closeModal\");\n\n      const signatureBN = {\n        v: new BN(signature.v, 16),\n        r: new BN(signature.r, 16),\n        s: new BN(signature.s, 16),\n      };\n\n      const chainId = await web3.eth.getChainId();\n      const networkId = await web3.eth.net.getId();\n      const chainParams = {\n        common: EthereumjsCommon.forCustomChain(\n          \"mainnet\",\n          { networkId, chainId },\n          \"istanbul\"\n        ),\n      };\n\n      const signedTx = Transaction.fromTxData(\n        {\n          nonce: tx.nonce,\n          gasPrice: tx.gasPrice,\n          gasLimit: tx.gasLimit,\n          to: tx.to,\n          value: tx.value,\n          data: tx.data,\n          ...signatureBN,\n        },\n        chainParams\n      );\n      return signedTx;\n    } catch (e) {\n      store.commit(\"Ledger/closeModal\");\n      console.error(e);\n      throw e;\n    }\n  }\n\n  getEvmAddress(): string {\n    return this.ethAddress;\n  }\n\n  async getStake(): Promise<BN> {\n    this.stakeAmount = await WalletHelper.getStake(this);\n    return this.stakeAmount;\n  }\n\n  async getEthBalance() {\n    const bal = await WalletHelper.getEthBalance(this);\n    this.ethBalance = bal;\n    return bal;\n  }\n\n  async getUTXOs(): Promise<void> {\n    // TODO: Move to shared file\n    this.isFetchUtxos = true;\n    // If we are waiting for helpers to initialize delay the call\n    const isInit =\n      this.externalHelper.isInit &&\n      this.internalHelper.isInit &&\n      this.platformHelper.isInit;\n    if (!isInit) {\n      setTimeout(() => {\n        this.getUTXOs();\n      }, 1000);\n      return;\n    }\n\n    super.getUTXOs();\n    this.getStake();\n    this.getEthBalance();\n    return;\n  }\n\n  getPathFromAddress(address: string) {\n    const externalAddrs = this.externalHelper.getExtendedAddresses();\n    const internalAddrs = this.internalHelper.getExtendedAddresses();\n    const platformAddrs = this.platformHelper.getExtendedAddresses();\n\n    const extIndex = externalAddrs.indexOf(address);\n    const intIndex = internalAddrs.indexOf(address);\n    const platformIndex = platformAddrs.indexOf(address);\n\n    if (extIndex >= 0) {\n      return `0/${extIndex}`;\n    } else if (intIndex >= 0) {\n      return `1/${intIndex}`;\n    } else if (platformIndex >= 0) {\n      return `0/${platformIndex}`;\n    } else if (address[0] === \"C\") {\n      return \"0/0\";\n    } else {\n      throw \"Unable to find source address.\";\n    }\n  }\n\n  async issueBatchTx(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    memo: Buffer | undefined\n  ): Promise<string> {\n    return await WalletHelper.issueBatchTx(this, orders, addr, memo);\n  }\n\n  async delegate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.delegate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async validate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    delegationFee: number,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.validate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      delegationFee,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async signHashByExternalIndex(index: number, hash: Buffer) {\n    const pathStr = `0/${index}`;\n    const addressPath = bippath.fromString(pathStr, false);\n    const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`);\n\n    store.commit(\"Ledger/openModal\", {\n      title: `Sign Hash`,\n      info: hash.toString(\"hex\").toUpperCase(),\n    });\n\n    try {\n      const sigMap = await this.app.signHash(accountPath, [addressPath], hash);\n      store.commit(\"Ledger/closeModal\");\n      const signed = sigMap.get(pathStr);\n      return bintools.cb58Encode(signed);\n    } catch (e) {\n      store.commit(\"Ledger/closeModal\");\n      throw e;\n    }\n  }\n\n  async createNftFamily(name: string, symbol: string, groupNum: number) {\n    return await WalletHelper.createNftFamily(this, name, symbol, groupNum);\n  }\n\n  async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n    return await WalletHelper.mintNft(this, mintUtxo, payload, quantity);\n  }\n\n  async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n    return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit);\n  }\n\n  async estimateGas(\n    to: string,\n    amount: BN,\n    token: Erc20Token\n  ): Promise<number> {\n    return await WalletHelper.estimateGas(this, to, amount, token);\n  }\n\n  async sendERC20(\n    to: string,\n    amount: BN,\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n  ): Promise<string> {\n    // throw 'Not Implemented'\n    return await WalletHelper.sendErc20(\n      this,\n      to,\n      amount,\n      gasPrice,\n      gasLimit,\n      token\n    );\n  }\n}\n\nexport { LedgerWallet };\n","import axios, { AxiosInstance } from \"axios\";\nimport sha3 from \"js-sha3\";\nconst elliptic = require(\"elliptic\");\nconst ec = new elliptic.ec(\"secp256k1\");\nexport interface AccessToken {\n  access_token: string;\n}\ninterface GetNonceType {\n  nonce: string;\n}\n\nconst BASE_URL = \"https://api.kyc.camino.network/v2\";\n\nconst kyc_api: AxiosInstance = axios.create({\n  baseURL: BASE_URL,\n  withCredentials: false,\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n});\n\nasync function getNonce(): Promise<GetNonceType> {\n  const res = await kyc_api.get(\"/nonce\");\n  return res.data;\n}\n\nexport function getPublicKey(privateKey: string): string | null {\n  const keyPair = ec.keyFromPrivate(privateKey);\n  const pubKey = keyPair.getPublic();\n  return pubKey.encode(\"hex\", false);\n}\n\nasync function generateToken(privateKey: string): Promise<AccessToken> {\n  const keyPair = ec.keyFromPrivate(privateKey);\n  const privKey = keyPair.getPrivate(\"hex\");\n  const pubKey = keyPair.getPublic();\n  const { nonce } = await getNonce();\n  const msgHash = sha3.keccak_256(Buffer.from(nonce, \"hex\"));\n  const signature = ec.sign(msgHash, privKey, \"hex\", { canonical: true });\n  const req = {\n    nonce: nonce,\n    signature: Buffer.concat([\n      signature.r.toArrayLike(Buffer, \"be\", 32),\n      signature.s.toArrayLike(Buffer, \"be\", 32),\n      Buffer.from([signature.recoveryParam]),\n    ]).toString(\"hex\"),\n    public_key: pubKey.encode(\"hex\", false),\n  };\n  const res = await kyc_api.post(\"/accessToken\", req);\n  return res.data;\n}\n\nasync function checkVerificationStatus(\n  privateKey: string,\n  activeNetworkName: string\n): Promise<boolean> {\n  const keyPair = ec.keyFromPrivate(privateKey);\n  const pubKey = keyPair.getPublic();\n  const url = `/verified/${activeNetworkName}/${pubKey.encode(\"hex\", false)}`;\n\n  const res = await kyc_api.get(url);\n  return res.data.kyc_verified;\n}\n\nexport { kyc_api, generateToken, checkVerificationStatus };\n","var isoLangs = {\n  ab: {\n    name: \"Abkhaz\",\n    nativeName: \"аҧсуа\",\n  },\n  aa: {\n    name: \"Afar\",\n    nativeName: \"Afaraf\",\n  },\n  af: {\n    name: \"Afrikaans\",\n    nativeName: \"Afrikaans\",\n  },\n  ak: {\n    name: \"Akan\",\n    nativeName: \"Akan\",\n  },\n  sq: {\n    name: \"Albanian\",\n    nativeName: \"Shqip\",\n  },\n  am: {\n    name: \"Amharic\",\n    nativeName: \"አማርኛ\",\n  },\n  ar: {\n    name: \"Arabic\",\n    nativeName: \"العربية\",\n  },\n  an: {\n    name: \"Aragonese\",\n    nativeName: \"Aragonés\",\n  },\n  hy: {\n    name: \"Armenian\",\n    nativeName: \"Հայերեն\",\n  },\n  as: {\n    name: \"Assamese\",\n    nativeName: \"অসমীয়া\",\n  },\n  av: {\n    name: \"Avaric\",\n    nativeName: \"авар мацӀ, магӀарул мацӀ\",\n  },\n  ae: {\n    name: \"Avestan\",\n    nativeName: \"avesta\",\n  },\n  ay: {\n    name: \"Aymara\",\n    nativeName: \"aymar aru\",\n  },\n  az: {\n    name: \"Azerbaijani\",\n    nativeName: \"azərbaycan dili\",\n  },\n  bm: {\n    name: \"Bambara\",\n    nativeName: \"bamanankan\",\n  },\n  ba: {\n    name: \"Bashkir\",\n    nativeName: \"башҡорт теле\",\n  },\n  eu: {\n    name: \"Basque\",\n    nativeName: \"euskara, euskera\",\n  },\n  be: {\n    name: \"Belarusian\",\n    nativeName: \"Беларуская\",\n  },\n  bn: {\n    name: \"Bengali\",\n    nativeName: \"বাংলা\",\n  },\n  bh: {\n    name: \"Bihari\",\n    nativeName: \"भोजपुरी\",\n  },\n  bi: {\n    name: \"Bislama\",\n    nativeName: \"Bislama\",\n  },\n  bs: {\n    name: \"Bosnian\",\n    nativeName: \"bosanski jezik\",\n  },\n  br: {\n    name: \"Breton\",\n    nativeName: \"brezhoneg\",\n  },\n  bg: {\n    name: \"Bulgarian\",\n    nativeName: \"български език\",\n  },\n  my: {\n    name: \"Burmese\",\n    nativeName: \"ဗမာစာ\",\n  },\n  ca: {\n    name: \"Catalan; Valencian\",\n    nativeName: \"Català\",\n  },\n  ch: {\n    name: \"Chamorro\",\n    nativeName: \"Chamoru\",\n  },\n  ce: {\n    name: \"Chechen\",\n    nativeName: \"нохчийн мотт\",\n  },\n  ny: {\n    name: \"Chichewa; Chewa; Nyanja\",\n    nativeName: \"chiCheŵa, chinyanja\",\n  },\n  cn: {\n    name: \"Chinese\",\n    nativeName: \"中文 (Zhōngwén), 汉语, 漢語\",\n  },\n  zh_hans: {\n    name: \"Chinese (Simplified)\",\n    nativeName: \"汉语\",\n  },\n  zh_hant: {\n    name: \"Chinese (Traditional)\",\n    nativeName: \"漢語\",\n  },\n  cv: {\n    name: \"Chuvash\",\n    nativeName: \"чӑваш чӗлхи\",\n  },\n  kw: {\n    name: \"Cornish\",\n    nativeName: \"Kernewek\",\n  },\n  co: {\n    name: \"Corsican\",\n    nativeName: \"corsu, lingua corsa\",\n  },\n  cr: {\n    name: \"Cree\",\n    nativeName: \"ᓀᐦᐃᔭᐍᐏᐣ\",\n  },\n  hr: {\n    name: \"Croatian\",\n    nativeName: \"hrvatski\",\n  },\n  cs: {\n    name: \"Czech\",\n    nativeName: \"česky, čeština\",\n  },\n  da: {\n    name: \"Danish\",\n    nativeName: \"dansk\",\n  },\n  dv: {\n    name: \"Divehi; Dhivehi; Maldivian;\",\n    nativeName: \"ދިވެހި\",\n  },\n  nl: {\n    name: \"Dutch\",\n    nativeName: \"Nederlands, Vlaams\",\n  },\n  en: {\n    name: \"EN\",\n    nativeName: \"EN\",\n  },\n  eo: {\n    name: \"Esperanto\",\n    nativeName: \"Esperanto\",\n  },\n  et: {\n    name: \"Estonian\",\n    nativeName: \"eesti, eesti keel\",\n  },\n  ee: {\n    name: \"Ewe\",\n    nativeName: \"Eʋegbe\",\n  },\n  fo: {\n    name: \"Faroese\",\n    nativeName: \"føroyskt\",\n  },\n  fj: {\n    name: \"Fijian\",\n    nativeName: \"vosa Vakaviti\",\n  },\n  fi: {\n    name: \"Finnish\",\n    nativeName: \"suomi, suomen kieli\",\n  },\n  fr: {\n    name: \"French\",\n    nativeName: \"Français\",\n  },\n  ff: {\n    name: \"Fula; Fulah; Pulaar; Pular\",\n    nativeName: \"Fulfulde, Pulaar, Pular\",\n  },\n  gl: {\n    name: \"Galician\",\n    nativeName: \"Galego\",\n  },\n  ka: {\n    name: \"Georgian\",\n    nativeName: \"ქართული\",\n  },\n  de: {\n    name: \"German\",\n    nativeName: \"Deutsch\",\n  },\n  el: {\n    name: \"Greek, Modern\",\n    nativeName: \"Ελληνικά\",\n  },\n  gn: {\n    name: \"Guaraní\",\n    nativeName: \"Avañeẽ\",\n  },\n  gu: {\n    name: \"Gujarati\",\n    nativeName: \"ગુજરાતી\",\n  },\n  ht: {\n    name: \"Haitian; Haitian Creole\",\n    nativeName: \"Kreyòl ayisyen\",\n  },\n  ha: {\n    name: \"Hausa\",\n    nativeName: \"Hausa, هَوُسَ\",\n  },\n  he: {\n    name: \"Hebrew (modern)\",\n    nativeName: \"עברית\",\n  },\n  hz: {\n    name: \"Herero\",\n    nativeName: \"Otjiherero\",\n  },\n  hi: {\n    name: \"Hindi\",\n    nativeName: \"हिन्दी, हिंदी\",\n  },\n  ho: {\n    name: \"Hiri Motu\",\n    nativeName: \"Hiri Motu\",\n  },\n  hu: {\n    name: \"Hungarian\",\n    nativeName: \"Magyar\",\n  },\n  ia: {\n    name: \"Interlingua\",\n    nativeName: \"Interlingua\",\n  },\n  id: {\n    name: \"Indonesian\",\n    nativeName: \"Bahasa Indonesia\",\n  },\n  ie: {\n    name: \"Interlingue\",\n    nativeName: \"Originally called Occidental; then Interlingue after WWII\",\n  },\n  ga: {\n    name: \"Irish\",\n    nativeName: \"Gaeilge\",\n  },\n  ig: {\n    name: \"Igbo\",\n    nativeName: \"Asụsụ Igbo\",\n  },\n  ik: {\n    name: \"Inupiaq\",\n    nativeName: \"Iñupiaq, Iñupiatun\",\n  },\n  io: {\n    name: \"Ido\",\n    nativeName: \"Ido\",\n  },\n  is: {\n    name: \"Icelandic\",\n    nativeName: \"Íslenska\",\n  },\n  it: {\n    name: \"Italian\",\n    nativeName: \"Italiano\",\n  },\n  iu: {\n    name: \"Inuktitut\",\n    nativeName: \"ᐃᓄᒃᑎᑐᑦ\",\n  },\n  ja: {\n    name: \"Japanese\",\n    nativeName: \"日本語\",\n  },\n  jv: {\n    name: \"Javanese\",\n    nativeName: \"basa Jawa\",\n  },\n  kl: {\n    name: \"Kalaallisut, Greenlandic\",\n    nativeName: \"kalaallisut, kalaallit oqaasii\",\n  },\n  kn: {\n    name: \"Kannada\",\n    nativeName: \"ಕನ್ನಡ\",\n  },\n  // \"kr\": {\n  //     \"name\": \"Kanuri\",\n  //     \"nativeName\": \"Kanuri\"\n  // },\n  ks: {\n    name: \"Kashmiri\",\n    nativeName: \"कश्मीरी, كشميري‎\",\n  },\n  kk: {\n    name: \"Kazakh\",\n    nativeName: \"Қазақ тілі\",\n  },\n  km: {\n    name: \"Khmer\",\n    nativeName: \"ភាសាខ្មែរ\",\n  },\n  ki: {\n    name: \"Kikuyu, Gikuyu\",\n    nativeName: \"Gĩkũyũ\",\n  },\n  rw: {\n    name: \"Kinyarwanda\",\n    nativeName: \"Ikinyarwanda\",\n  },\n  ky: {\n    name: \"Kirghiz, Kyrgyz\",\n    nativeName: \"кыргыз тили\",\n  },\n  kv: {\n    name: \"Komi\",\n    nativeName: \"коми кыв\",\n  },\n  kg: {\n    name: \"Kongo\",\n    nativeName: \"KiKongo\",\n  },\n  kr: {\n    name: \"Korean\",\n    nativeName: \"한국어\",\n  },\n  ku: {\n    name: \"Kurdish\",\n    nativeName: \"Kurdî, كوردی‎\",\n  },\n  kj: {\n    name: \"Kwanyama, Kuanyama\",\n    nativeName: \"Kuanyama\",\n  },\n  la: {\n    name: \"Latin\",\n    nativeName: \"latine, lingua latina\",\n  },\n  lb: {\n    name: \"Luxembourgish, Letzeburgesch\",\n    nativeName: \"Lëtzebuergesch\",\n  },\n  lg: {\n    name: \"Luganda\",\n    nativeName: \"Luganda\",\n  },\n  li: {\n    name: \"Limburgish, Limburgan, Limburger\",\n    nativeName: \"Limburgs\",\n  },\n  ln: {\n    name: \"Lingala\",\n    nativeName: \"Lingála\",\n  },\n  lo: {\n    name: \"Lao\",\n    nativeName: \"ພາສາລາວ\",\n  },\n  lt: {\n    name: \"Lithuanian\",\n    nativeName: \"lietuvių kalba\",\n  },\n  lu: {\n    name: \"Luba-Katanga\",\n    nativeName: \"\",\n  },\n  lv: {\n    name: \"Latvian\",\n    nativeName: \"latviešu valoda\",\n  },\n  gv: {\n    name: \"Manx\",\n    nativeName: \"Gaelg, Gailck\",\n  },\n  mk: {\n    name: \"Macedonian\",\n    nativeName: \"македонски јазик\",\n  },\n  mg: {\n    name: \"Malagasy\",\n    nativeName: \"Malagasy fiteny\",\n  },\n  ms: {\n    name: \"Malay\",\n    nativeName: \"bahasa Melayu, بهاس ملايو‎\",\n  },\n  ml: {\n    name: \"Malayalam\",\n    nativeName: \"മലയാളം\",\n  },\n  mt: {\n    name: \"Maltese\",\n    nativeName: \"Malti\",\n  },\n  mi: {\n    name: \"Māori\",\n    nativeName: \"te reo Māori\",\n  },\n  mr: {\n    name: \"Marathi (Marāṭhī)\",\n    nativeName: \"मराठी\",\n  },\n  mh: {\n    name: \"Marshallese\",\n    nativeName: \"Kajin M̧ajeļ\",\n  },\n  mn: {\n    name: \"Mongolian\",\n    nativeName: \"монгол\",\n  },\n  na: {\n    name: \"Nauru\",\n    nativeName: \"Ekakairũ Naoero\",\n  },\n  nv: {\n    name: \"Navajo, Navaho\",\n    nativeName: \"Diné bizaad, Dinékʼehǰí\",\n  },\n  nb: {\n    name: \"Norwegian Bokmål\",\n    nativeName: \"Norsk bokmål\",\n  },\n  nd: {\n    name: \"North Ndebele\",\n    nativeName: \"isiNdebele\",\n  },\n  ne: {\n    name: \"Nepali\",\n    nativeName: \"नेपाली\",\n  },\n  ng: {\n    name: \"Ndonga\",\n    nativeName: \"Owambo\",\n  },\n  nn: {\n    name: \"Norwegian Nynorsk\",\n    nativeName: \"Norsk nynorsk\",\n  },\n  no: {\n    name: \"Norwegian\",\n    nativeName: \"Norsk\",\n  },\n  ii: {\n    name: \"Nuosu\",\n    nativeName: \"ꆈꌠ꒿ Nuosuhxop\",\n  },\n  nr: {\n    name: \"South Ndebele\",\n    nativeName: \"isiNdebele\",\n  },\n  oc: {\n    name: \"Occitan\",\n    nativeName: \"Occitan\",\n  },\n  oj: {\n    name: \"Ojibwe, Ojibwa\",\n    nativeName: \"ᐊᓂᔑᓈᐯᒧᐎᓐ\",\n  },\n  cu: {\n    name:\n      \"Old Church Slavonic, Church Slavic, Church Slavonic, Old Bulgarian, Old Slavonic\",\n    nativeName: \"ѩзыкъ словѣньскъ\",\n  },\n  om: {\n    name: \"Oromo\",\n    nativeName: \"Afaan Oromoo\",\n  },\n  or: {\n    name: \"Oriya\",\n    nativeName: \"ଓଡ଼ିଆ\",\n  },\n  os: {\n    name: \"Ossetian, Ossetic\",\n    nativeName: \"ирон æвзаг\",\n  },\n  pa: {\n    name: \"Panjabi, Punjabi\",\n    nativeName: \"ਪੰਜਾਬੀ, پنجابی‎\",\n  },\n  pi: {\n    name: \"Pāli\",\n    nativeName: \"पाऴि\",\n  },\n  fa: {\n    name: \"Persian\",\n    nativeName: \"فارسی\",\n  },\n  pl: {\n    name: \"Polish\",\n    nativeName: \"polski\",\n  },\n  ps: {\n    name: \"Pashto, Pushto\",\n    nativeName: \"پښتو\",\n  },\n  pt: {\n    name: \"Portuguese\",\n    nativeName: \"Português\",\n  },\n  qu: {\n    name: \"Quechua\",\n    nativeName: \"Runa Simi, Kichwa\",\n  },\n  rm: {\n    name: \"Romansh\",\n    nativeName: \"rumantsch grischun\",\n  },\n  rn: {\n    name: \"Kirundi\",\n    nativeName: \"kiRundi\",\n  },\n  ro: {\n    name: \"Romanian, Moldavian, Moldovan\",\n    nativeName: \"română\",\n  },\n  ru: {\n    name: \"Russian\",\n    nativeName: \"русский язык\",\n  },\n  sa: {\n    name: \"Sanskrit (Saṁskṛta)\",\n    nativeName: \"संस्कृतम्\",\n  },\n  sc: {\n    name: \"Sardinian\",\n    nativeName: \"sardu\",\n  },\n  sd: {\n    name: \"Sindhi\",\n    nativeName: \"सिन्धी, سنڌي، سندھی‎\",\n  },\n  se: {\n    name: \"Northern Sami\",\n    nativeName: \"Davvisámegiella\",\n  },\n  sm: {\n    name: \"Samoan\",\n    nativeName: \"gagana faa Samoa\",\n  },\n  sg: {\n    name: \"Sango\",\n    nativeName: \"yângâ tî sängö\",\n  },\n  sr: {\n    name: \"Serbian\",\n    nativeName: \"српски језик\",\n  },\n  gd: {\n    name: \"Scottish Gaelic; Gaelic\",\n    nativeName: \"Gàidhlig\",\n  },\n  sn: {\n    name: \"Shona\",\n    nativeName: \"chiShona\",\n  },\n  si: {\n    name: \"Sinhala, Sinhalese\",\n    nativeName: \"සිංහල\",\n  },\n  sk: {\n    name: \"Slovak\",\n    nativeName: \"slovenčina\",\n  },\n  sl: {\n    name: \"Slovene\",\n    nativeName: \"slovenščina\",\n  },\n  so: {\n    name: \"Somali\",\n    nativeName: \"Soomaaliga, af Soomaali\",\n  },\n  st: {\n    name: \"Southern Sotho\",\n    nativeName: \"Sesotho\",\n  },\n  es: {\n    name: \"Spanish; Castilian\",\n    nativeName: \"Español\",\n  },\n  su: {\n    name: \"Sundanese\",\n    nativeName: \"Basa Sunda\",\n  },\n  sw: {\n    name: \"Swahili\",\n    nativeName: \"Kiswahili\",\n  },\n  ss: {\n    name: \"Swati\",\n    nativeName: \"SiSwati\",\n  },\n  sv: {\n    name: \"Swedish\",\n    nativeName: \"svenska\",\n  },\n  ta: {\n    name: \"Tamil\",\n    nativeName: \"தமிழ்\",\n  },\n  te: {\n    name: \"Telugu\",\n    nativeName: \"తెలుగు\",\n  },\n  tg: {\n    name: \"Tajik\",\n    nativeName: \"тоҷикӣ, toğikī, تاجیکی‎\",\n  },\n  th: {\n    name: \"Thai\",\n    nativeName: \"ไทย\",\n  },\n  ti: {\n    name: \"Tigrinya\",\n    nativeName: \"ትግርኛ\",\n  },\n  bo: {\n    name: \"Tibetan Standard, Tibetan, Central\",\n    nativeName: \"བོད་ཡིག\",\n  },\n  tk: {\n    name: \"Turkmen\",\n    nativeName: \"Türkmen, Түркмен\",\n  },\n  tl: {\n    name: \"Tagalog\",\n    nativeName: \"Wikang Tagalog, ᜏᜒᜃᜅ᜔ ᜆᜄᜎᜓᜄ᜔\",\n  },\n  tn: {\n    name: \"Tswana\",\n    nativeName: \"Setswana\",\n  },\n  to: {\n    name: \"Tonga (Tonga Islands)\",\n    nativeName: \"faka Tonga\",\n  },\n  tr: {\n    name: \"Turkish\",\n    nativeName: \"Türkçe\",\n  },\n  ts: {\n    name: \"Tsonga\",\n    nativeName: \"Xitsonga\",\n  },\n  tt: {\n    name: \"Tatar\",\n    nativeName: \"татарча, tatarça, تاتارچا‎\",\n  },\n  tw: {\n    name: \"Twi\",\n    nativeName: \"Twi\",\n  },\n  ty: {\n    name: \"Tahitian\",\n    nativeName: \"Reo Tahiti\",\n  },\n  ug: {\n    name: \"Uighur, Uyghur\",\n    nativeName: \"Uyƣurqə, ئۇيغۇرچە‎\",\n  },\n  uk: {\n    name: \"Ukrainian\",\n    nativeName: \"українська\",\n  },\n  ur: {\n    name: \"Urdu\",\n    nativeName: \"اردو\",\n  },\n  uz: {\n    name: \"Uzbek\",\n    nativeName: \"zbek, Ўзбек, أۇزبېك‎\",\n  },\n  ve: {\n    name: \"Venda\",\n    nativeName: \"Tshivenḓa\",\n  },\n  vn: {\n    name: \"Vietnamese\",\n    nativeName: \"Tiếng Việt\",\n  },\n  vo: {\n    name: \"Volapük\",\n    nativeName: \"Volapük\",\n  },\n  wa: {\n    name: \"Walloon\",\n    nativeName: \"Walon\",\n  },\n  cy: {\n    name: \"Welsh\",\n    nativeName: \"Cymraeg\",\n  },\n  wo: {\n    name: \"Wolof\",\n    nativeName: \"Wollof\",\n  },\n  fy: {\n    name: \"Western Frisian\",\n    nativeName: \"Frysk\",\n  },\n  xh: {\n    name: \"Xhosa\",\n    nativeName: \"isiXhosa\",\n  },\n  yi: {\n    name: \"Yiddish\",\n    nativeName: \"ייִדיש\",\n  },\n  yo: {\n    name: \"Yoruba\",\n    nativeName: \"Yorùbá\",\n  },\n  za: {\n    name: \"Zhuang, Chuang\",\n    nativeName: \"Saɯ cueŋƅ, Saw cuengh\",\n  },\n};\n\nexport default isoLangs;\n","import CryptoJS from \"crypto-js/core\";\nimport AES from \"crypto-js/aes\";\nconst randomstring = require(\"randomstring\");\nimport * as bip39 from \"bip39\";\n\n// The purpose of this class is for obfuscation only rather than secure encryption\nexport default class MnemonicPhrase {\n  private pass: string;\n  private encrypted: any;\n\n  constructor(mnemonic: string) {\n    if (!bip39.validateMnemonic(mnemonic))\n      throw new Error(\"Invalid mnemonic phrase.\");\n    this.pass = randomstring.generate(32);\n    this.encrypted = AES.encrypt(mnemonic, this.pass).toString();\n  }\n\n  public getValue() {\n    const decrypted = AES.decrypt(this.encrypted, this.pass).toString(\n      CryptoJS.enc.Utf8\n    );\n    if (!bip39.validateMnemonic(decrypted))\n      throw new Error(\"Decrypted mnemonic is not valid.\");\n    return decrypted;\n  }\n}\n","import { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport { ITransaction } from \"@/components/wallet/transfer/types\";\nimport { digestMessage } from \"@/helpers/helper\";\nimport { WalletNameType } from \"@/js/wallets/types\";\n\nimport { Buffer as BufferAvalanche, BN } from \"avalanche\";\nimport {\n  KeyPair as AVMKeyPair,\n  KeyChain as AVMKeyChain,\n  UTXOSet as AVMUTXOSet,\n  UTXO,\n  UnsignedTx,\n} from \"avalanche/dist/apis/avm\";\nimport {\n  KeyPair as PlatformKeyPair,\n  KeyChain as PlatformKeyChain,\n  UTXOSet as PlatformUTXOSet,\n  UTXOSet,\n} from \"avalanche/dist/apis/platformvm\";\nimport {\n  KeyChain,\n  KeyChain as EVMKeyChain,\n  UTXOSet as EVMUTXOSet,\n} from \"avalanche/dist/apis/evm\";\nimport { PayloadBase } from \"avalanche/dist/utils\";\nimport { buildUnsignedTransaction } from \"../TxHelper\";\nimport { AvaWalletCore, UnsafeWallet } from \"./types\";\nimport { UTXO as PlatformUTXO } from \"avalanche/dist/apis/platformvm/utxos\";\nimport { privateToAddress } from \"ethereumjs-util\";\nimport {\n  Tx as AVMTx,\n  UnsignedTx as AVMUnsignedTx,\n} from \"avalanche/dist/apis/avm/tx\";\nimport {\n  Tx as PlatformTx,\n  UnsignedTx as PlatformUnsignedTx,\n} from \"avalanche/dist/apis/platformvm/tx\";\nimport {\n  Tx as EvmTx,\n  UnsignedTx as EVMUnsignedTx,\n} from \"avalanche/dist/apis/evm/tx\";\nimport Erc20Token from \"@/js/Erc20Token\";\nimport { WalletCore } from \"@/js/wallets/WalletCore\";\nimport { WalletHelper } from \"@/helpers/wallet_helper\";\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from \"@/helpers/utxo_helper\";\nimport { UTXO as AVMUTXO } from \"avalanche/dist/apis/avm/utxos\";\nimport { Transaction } from \"@ethereumjs/tx\";\nimport {\n  ExportChainsC,\n  ExportChainsP,\n  ExportChainsX,\n} from \"@avalabs/avalanche-wallet-sdk\";\n\nclass SingletonWallet\n  extends WalletCore\n  implements AvaWalletCore, UnsafeWallet {\n  keyChain: AVMKeyChain;\n  keyPair: AVMKeyPair;\n\n  platformKeyChain: PlatformKeyChain;\n  platformKeyPair: PlatformKeyPair;\n\n  chainId: string;\n  chainIdP: string;\n\n  key: string;\n\n  stakeAmount: BN;\n\n  type: WalletNameType;\n\n  ethKey: string;\n  ethKeyBech: string;\n  ethKeyChain: EVMKeyChain;\n  ethAddress: string;\n  ethAddressBech: string;\n  ethBalance: BN;\n\n  constructor(pk: string) {\n    super();\n\n    this.key = pk;\n\n    this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID();\n    this.chainIdP = pChain.getBlockchainAlias() || pChain.getBlockchainID();\n\n    const hrp = ava.getHRP();\n\n    this.keyChain = new AVMKeyChain(hrp, this.chainId);\n    this.keyPair = this.keyChain.importKey(pk);\n\n    this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP);\n    this.platformKeyPair = this.platformKeyChain.importKey(pk);\n\n    this.stakeAmount = new BN(0);\n\n    // Derive EVM key and address\n    const pkBuf = bintools.cb58Decode(pk.split(\"-\")[1]);\n    const pkHex = pkBuf.toString(\"hex\");\n    const pkBuffNative = Buffer.from(pkHex, \"hex\");\n\n    this.ethKey = pkHex;\n    this.ethAddress = privateToAddress(pkBuffNative).toString(\"hex\");\n    this.ethBalance = new BN(0);\n\n    const cPrivKey =\n      `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(pkBuf));\n    this.ethKeyBech = cPrivKey;\n    const cKeyChain = new KeyChain(ava.getHRP(), \"C\");\n    this.ethKeyChain = cKeyChain;\n\n    const cKeypair = cKeyChain.importKey(cPrivKey);\n    this.ethAddressBech = cKeypair.getAddressString();\n\n    this.type = \"singleton\";\n    this.isInit = true;\n  }\n\n  getChangeAddressAvm(): string {\n    return this.getCurrentAddressAvm();\n  }\n\n  getCurrentAddressAvm(): string {\n    return this.keyPair.getAddressString();\n  }\n\n  getChangeAddressPlatform(): string {\n    return this.getCurrentAddressPlatform();\n  }\n\n  getDerivedAddresses(): string[] {\n    const addr = this.getCurrentAddressAvm();\n    return [addr];\n  }\n\n  getDerivedAddressesP() {\n    return [this.getCurrentAddressPlatform()];\n  }\n\n  getAllDerivedExternalAddresses(): string[] {\n    return this.getDerivedAddresses();\n  }\n\n  getExtendedPlatformAddresses(): string[] {\n    const addr = this.platformKeyPair.getAddressString();\n    return [addr];\n  }\n\n  getHistoryAddresses(): string[] {\n    const addr = this.getCurrentAddressAvm();\n    return [addr];\n  }\n\n  getPlatformRewardAddress(): string {\n    return this.getCurrentAddressPlatform();\n  }\n\n  getCurrentAddressPlatform(): string {\n    return this.platformKeyPair.getAddressString();\n  }\n\n  getBaseAddress(): string {\n    return this.getCurrentAddressAvm();\n  }\n\n  async getStake(): Promise<BN> {\n    this.stakeAmount = await WalletHelper.getStake(this);\n    return this.stakeAmount;\n  }\n\n  getPlatformUTXOSet(): PlatformUTXOSet {\n    return this.platformUtxoset;\n  }\n\n  getEvmAddress(): string {\n    return this.ethAddress;\n  }\n\n  getEvmAddressBech(): string {\n    return this.ethAddressBech;\n  }\n\n  async getEthBalance() {\n    const bal = await WalletHelper.getEthBalance(this);\n    this.ethBalance = bal;\n    return bal;\n  }\n\n  async updateUTXOsX(): Promise<AVMUTXOSet> {\n    const result = await avmGetAllUTXOs([this.getCurrentAddressAvm()]);\n    this.utxoset = result;\n    return result;\n  }\n\n  async updateUTXOsP(): Promise<PlatformUTXOSet> {\n    const result = await platformGetAllUTXOs([\n      this.getCurrentAddressPlatform(),\n    ]);\n    this.platformUtxoset = result;\n    return result;\n  }\n\n  async getUTXOs(): Promise<void> {\n    this.isFetchUtxos = true;\n\n    await this.updateUTXOsX();\n    await this.updateUTXOsP();\n\n    await this.getStake();\n    await this.getEthBalance();\n\n    this.isFetchUtxos = false;\n\n    return;\n  }\n\n  async buildUnsignedTransaction(\n    orders: (ITransaction | UTXO)[],\n    addr: string,\n    memo?: BufferAvalanche\n  ) {\n    const changeAddress = this.getChangeAddressAvm();\n    const derivedAddresses = this.getDerivedAddresses();\n    const utxoset = this.getUTXOSet() as AVMUTXOSet;\n\n    return buildUnsignedTransaction(\n      orders,\n      addr,\n      derivedAddresses,\n      utxoset,\n      changeAddress,\n      memo\n    );\n  }\n\n  async issueBatchTx(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    memo: BufferAvalanche | undefined\n  ): Promise<string> {\n    return await WalletHelper.issueBatchTx(this, orders, addr, memo);\n  }\n\n  getFirstAvailableAddressPlatform(): string {\n    return this.getCurrentAddressPlatform();\n  }\n\n  onnetworkchange(): void {\n    const hrp = ava.getHRP();\n\n    this.keyChain = new AVMKeyChain(hrp, this.chainId);\n    this.utxoset = new AVMUTXOSet();\n    this.keyPair = this.keyChain.importKey(this.key);\n\n    this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP);\n    this.platformUtxoset = new PlatformUTXOSet();\n    this.platformKeyPair = this.platformKeyChain.importKey(this.key);\n\n    // Update EVM values\n    this.ethKeyChain = new EVMKeyChain(ava.getHRP(), \"C\");\n    const cKeypair = this.ethKeyChain.importKey(this.ethKeyBech);\n    this.ethAddressBech = cKeypair.getAddressString();\n    this.ethBalance = new BN(0);\n\n    this.getUTXOs();\n  }\n\n  async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n    const keychain = this.keyChain;\n\n    const tx = unsignedTx.sign(keychain);\n    return tx;\n  }\n\n  async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n    const keychain = this.platformKeyChain;\n    const tx = unsignedTx.sign(keychain);\n    return tx;\n  }\n\n  async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n    const keyChain = this.ethKeyChain;\n    return unsignedTx.sign(keyChain);\n  }\n\n  async signEvm(tx: Transaction) {\n    const keyBuff = Buffer.from(this.ethKey, \"hex\");\n    return tx.sign(keyBuff);\n  }\n\n  async signMessage(msgStr: string): Promise<string> {\n    const digest = digestMessage(msgStr);\n\n    const digestHex = digest.toString(\"hex\");\n    const digestBuff = BufferAvalanche.from(digestHex, \"hex\");\n    const signed = this.keyPair.sign(digestBuff);\n\n    return bintools.cb58Encode(signed);\n  }\n\n  async delegate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.delegate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async validate(\n    nodeID: string,\n    amt: BN,\n    start: Date,\n    end: Date,\n    delegationFee: number = 0,\n    rewardAddress?: string,\n    utxos?: PlatformUTXO[]\n  ): Promise<string> {\n    return await WalletHelper.validate(\n      this,\n      nodeID,\n      amt,\n      start,\n      end,\n      delegationFee,\n      rewardAddress,\n      utxos\n    );\n  }\n\n  async createNftFamily(name: string, symbol: string, groupNum: number) {\n    return await WalletHelper.createNftFamily(this, name, symbol, groupNum);\n  }\n\n  async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n    return await WalletHelper.mintNft(this, mintUtxo, payload, quantity);\n  }\n\n  async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n    return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit);\n  }\n\n  async estimateGas(\n    to: string,\n    amount: BN,\n    token: Erc20Token\n  ): Promise<number> {\n    return await WalletHelper.estimateGas(this, to, amount, token);\n  }\n\n  async sendERC20(\n    to: string,\n    amount: BN,\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n  ): Promise<string> {\n    return await WalletHelper.sendErc20(\n      this,\n      to,\n      amount,\n      gasPrice,\n      gasLimit,\n      token\n    );\n  }\n\n  getAllAddressesX() {\n    return [this.getCurrentAddressAvm()];\n  }\n\n  getAllAddressesP() {\n    return [this.getCurrentAddressPlatform()];\n  }\n}\n\nexport { SingletonWallet };\n","class AvaNftFamily {\n  id: string;\n  name: string;\n  symbol: string;\n\n  constructor(id: string, name: string, symbol: string) {\n    this.id = id;\n    this.name = name;\n    this.symbol = symbol;\n  }\n}\n\nexport { AvaNftFamily };\n","/*\nThe base wallet class used for common functionality\n*/\nimport { BN } from \"avalanche\";\nimport { UTXOSet as AVMUTXOSet } from \"avalanche/dist/apis/avm\";\nimport { UTXOSet as PlatformUTXOSet } from \"avalanche/dist/apis/platformvm\";\nimport {\n  ExportChainsC,\n  ExportChainsP,\n  ExportChainsX,\n  UtxoHelper,\n  TxHelper,\n  GasHelper,\n  chainIdFromAlias,\n  xChain,\n} from \"@avalabs/avalanche-wallet-sdk\";\nimport { ava, avm, bintools, cChain, pChain } from \"@/AVA\";\nimport { UTXOSet as EVMUTXOSet } from \"avalanche/dist/apis/evm/utxos\";\nimport {\n  Tx as EVMTx,\n  UnsignedTx as EVMUnsignedTx,\n} from \"avalanche/dist/apis/evm/tx\";\nimport {\n  Tx as PlatformTx,\n  UnsignedTx as PlatformUnsignedTx,\n} from \"avalanche/dist/apis/platformvm/tx\";\nimport {\n  Tx as AVMTx,\n  UnsignedTx as AVMUnsignedTx,\n} from \"avalanche/dist/apis/avm/tx\";\nimport { AvmImportChainType, WalletType } from \"@/js/wallets/types\";\nimport { issueC, issueP, issueX } from \"@/helpers/issueTx\";\nconst uniqid = require(\"uniqid\");\n\nabstract class WalletCore {\n  id: string;\n\n  utxoset: AVMUTXOSet;\n  platformUtxoset: PlatformUTXOSet;\n  stakeAmount: BN;\n\n  isFetchUtxos: boolean;\n  isInit: boolean;\n\n  abstract getEvmAddressBech(): string;\n  abstract getEvmAddress(): string;\n  abstract getCurrentAddressAvm(): string;\n  abstract getChangeAddressAvm(): string;\n  abstract getCurrentAddressPlatform(): string;\n  abstract getAllAddressesP(): string[];\n  abstract getAllAddressesX(): string[];\n\n  abstract async signC(unsignedTx: EVMUnsignedTx): Promise<EVMTx>;\n  abstract async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx>;\n  abstract async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx>;\n\n  abstract async signMessage(msg: string, address?: string): Promise<string>;\n  abstract getPlatformUTXOSet(): PlatformUTXOSet;\n\n  getUTXOSet(): AVMUTXOSet {\n    return this.utxoset;\n  }\n\n  protected constructor() {\n    this.id = uniqid();\n    this.utxoset = new AVMUTXOSet();\n    this.platformUtxoset = new PlatformUTXOSet();\n    this.stakeAmount = new BN(0);\n\n    this.isInit = false;\n    this.isFetchUtxos = false;\n  }\n\n  async evmGetAtomicUTXOs(sourceChain: ExportChainsC) {\n    const addrs = [this.getEvmAddressBech()];\n    return await UtxoHelper.evmGetAtomicUTXOs(addrs, sourceChain);\n  }\n\n  async createImportTxC(\n    sourceChain: ExportChainsC,\n    utxoSet: EVMUTXOSet,\n    fee: BN\n  ) {\n    const bechAddr = this.getEvmAddressBech();\n    const hexAddr = this.getEvmAddress();\n\n    const toAddress = \"0x\" + hexAddr;\n    const ownerAddresses = [bechAddr];\n    const fromAddresses = ownerAddresses;\n    const sourceChainId = chainIdFromAlias(sourceChain);\n\n    return await cChain.buildImportTx(\n      utxoSet,\n      toAddress,\n      ownerAddresses,\n      sourceChainId,\n      fromAddresses,\n      fee\n    );\n  }\n\n  /**\n   *\n   * @param sourceChain\n   * @param fee Fee to use in nDJTX\n   * @param utxoSet\n   */\n  async importToCChain(\n    sourceChain: ExportChainsC,\n    fee: BN,\n    utxoSet?: EVMUTXOSet\n  ) {\n    if (!utxoSet) {\n      utxoSet = await this.evmGetAtomicUTXOs(sourceChain);\n    }\n\n    // TODO: Only use DJTX utxos\n    // TODO?: If the import fee for a utxo is greater than the value of the utxo, ignore it\n\n    if (utxoSet.getAllUTXOs().length === 0) {\n      throw new Error(\"Nothing to import.\");\n    }\n\n    const unsignedTxFee = await this.createImportTxC(sourceChain, utxoSet, fee);\n    const tx = await this.signC(unsignedTxFee);\n    return this.issueC(tx);\n  }\n\n  protected async issueX(tx: AVMTx) {\n    return issueX(tx);\n  }\n\n  protected async issueP(tx: PlatformTx) {\n    return issueP(tx);\n  }\n\n  protected async issueC(tx: EVMTx) {\n    return issueC(tx);\n  }\n\n  async exportFromXChain(\n    amt: BN,\n    destinationChain: ExportChainsX,\n    importFee?: BN\n  ) {\n    if (destinationChain === \"C\" && !importFee)\n      throw new Error(\"Exports to Utility chain must specify an import fee.\");\n\n    let amtFee = amt.clone();\n\n    // Get destination address\n    const destinationAddr =\n      destinationChain === \"P\"\n        ? this.getCurrentAddressPlatform()\n        : this.getEvmAddressBech();\n\n    // Add import fee to transaction\n    if (importFee) {\n      amtFee = amt.add(importFee);\n    } else if (destinationChain === \"P\") {\n      const fee = pChain.getTxFee();\n      amtFee = amt.add(fee);\n    }\n\n    const fromAddresses = this.getAllAddressesX();\n    const changeAddress = this.getChangeAddressAvm();\n    const utxos = this.getUTXOSet();\n    const exportTx = await TxHelper.buildAvmExportTransaction(\n      destinationChain,\n      utxos,\n      fromAddresses,\n      destinationAddr,\n      amtFee,\n      changeAddress\n    );\n\n    const tx = await this.signX(exportTx);\n\n    return this.issueX(tx);\n  }\n\n  async exportFromPChain(\n    amt: BN,\n    destinationChain: ExportChainsP,\n    importFee?: BN\n  ) {\n    const utxoSet = this.getPlatformUTXOSet();\n\n    const pChangeAddr = this.getCurrentAddressPlatform();\n    const fromAddrs = this.getAllAddressesP();\n\n    if (destinationChain === \"C\" && !importFee)\n      throw new Error(\"Exports to Utility chain must specify an import fee.\");\n\n    // Calculate C chain import fee\n    let amtFee = amt.clone();\n    if (importFee) {\n      amtFee = amt.add(importFee);\n    } else if (destinationChain === \"X\") {\n      // We can add the import fee for X chain\n      const fee = avm.getTxFee();\n      amtFee = amt.add(fee);\n    }\n\n    // Get the destination address for the right chain\n    const destinationAddr =\n      destinationChain === \"C\"\n        ? this.getEvmAddressBech()\n        : this.getCurrentAddressAvm();\n\n    const exportTx = await TxHelper.buildPlatformExportTransaction(\n      utxoSet,\n      fromAddrs,\n      destinationAddr,\n      amtFee,\n      pChangeAddr,\n      destinationChain\n    );\n\n    const tx = await this.signP(exportTx);\n    return await this.issueP(tx);\n  }\n\n  /**\n   *\n   * @param amt The amount to receive on the destination chain, in nDJTX.\n   * @param destinationChain `X` or `P`\n   * @param fee Fee to use in the export transaction, given in nDJTX.\n   */\n  async exportFromCChain(\n    amt: BN,\n    destinationChain: ExportChainsC,\n    exportFee: BN\n  ) {\n    // Add import fee\n    // X and P have the same fee\n    const importFee = avm.getTxFee();\n    const amtFee = amt.add(importFee);\n\n    const hexAddr = this.getEvmAddress();\n    const bechAddr = this.getEvmAddressBech();\n\n    const fromAddresses = [hexAddr];\n\n    const destinationAddr =\n      destinationChain === \"X\"\n        ? this.getCurrentAddressAvm()\n        : this.getCurrentAddressPlatform();\n\n    const exportTx = await TxHelper.buildEvmExportTransaction(\n      fromAddresses,\n      destinationAddr,\n      amtFee,\n      bechAddr,\n      destinationChain,\n      exportFee\n    );\n\n    const tx = await this.signC(exportTx);\n    return this.issueC(tx);\n  }\n\n  /**\n   * Returns the estimated gas to export from C chain.\n   * @param destinationChain\n   * @param amount\n   */\n  async estimateExportFee(\n    destinationChain: ExportChainsC,\n    amount: BN\n  ): Promise<number> {\n    const hexAddr = this.getEvmAddress();\n    const bechAddr = this.getEvmAddressBech();\n\n    const destinationAddr =\n      destinationChain === \"X\"\n        ? this.getCurrentAddressAvm()\n        : this.getCurrentAddressPlatform();\n\n    return GasHelper.estimateExportGasFee(\n      destinationChain,\n      hexAddr,\n      bechAddr,\n      destinationAddr,\n      amount\n    );\n  }\n\n  async avmGetAtomicUTXOs(sourceChain: ExportChainsX) {\n    const addrs = this.getAllAddressesX();\n    return await UtxoHelper.avmGetAtomicUTXOs(addrs, sourceChain);\n  }\n\n  async platformGetAtomicUTXOs(sourceChain: ExportChainsP) {\n    const addrs = this.getAllAddressesP();\n    return await UtxoHelper.platformGetAtomicUTXOs(addrs, sourceChain);\n  }\n\n  async importToPlatformChain(sourceChain: ExportChainsP): Promise<string> {\n    const utxoSet = await this.platformGetAtomicUTXOs(sourceChain);\n\n    if (utxoSet.getAllUTXOs().length === 0) {\n      throw new Error(\"Nothing to import.\");\n    }\n\n    const sourceChainId = chainIdFromAlias(sourceChain);\n    // Owner addresses, the addresses we exported to\n    const pToAddr = this.getCurrentAddressPlatform();\n\n    const hrp = ava.getHRP();\n    const utxoAddrs = utxoSet\n      .getAddresses()\n      .map((addr) => bintools.addressToString(hrp, \"P\", addr));\n\n    const fromAddrs = utxoAddrs;\n    const ownerAddrs = utxoAddrs;\n\n    const unsignedTx = await pChain.buildImportTx(\n      utxoSet,\n      ownerAddrs,\n      sourceChainId,\n      [pToAddr],\n      [pToAddr],\n      [pToAddr],\n      undefined,\n      undefined\n    );\n    const tx = await this.signP(unsignedTx);\n    // Pass in string because AJS fails to verify Tx type\n    return this.issueP(tx);\n  }\n\n  async importToXChain(sourceChain: AvmImportChainType) {\n    const utxoSet = await this.avmGetAtomicUTXOs(sourceChain);\n\n    if (utxoSet.getAllUTXOs().length === 0) {\n      throw new Error(\"Nothing to import.\");\n    }\n\n    const xToAddr = this.getCurrentAddressAvm();\n\n    const hrp = ava.getHRP();\n    const utxoAddrs = utxoSet\n      .getAddresses()\n      .map((addr) => bintools.addressToString(hrp, \"X\", addr));\n\n    const fromAddrs = utxoAddrs;\n    const ownerAddrs = utxoAddrs;\n\n    const sourceChainId = chainIdFromAlias(sourceChain);\n\n    // Owner addresses, the addresses we exported to\n    const unsignedTx = await avm.buildImportTx(\n      utxoSet,\n      ownerAddrs,\n      sourceChainId,\n      [xToAddr],\n      fromAddrs,\n      [xToAddr]\n    );\n\n    const tx = await this.signX(unsignedTx);\n    return this.issueX(tx);\n  }\n}\nexport { WalletCore };\n","// Manages BigNumber and Ava conversion and arithmetic\nimport { BN } from \"avalanche\";\nimport Big from \"big.js\";\n\nclass AvaAsset {\n  id: string;\n  name: string;\n  symbol: string;\n  denomination: number;\n  amount: BN;\n  amountLocked: BN;\n  amountMultisig: BN;\n  // DJTX P chain, Wallet Staking\n  amountExtra: BN;\n  private readonly pow: Big;\n  constructor(id: string, name: string, symbol: string, denomination: number) {\n    this.id = id;\n    this.name = name;\n    this.symbol = symbol;\n    this.denomination = denomination;\n    this.amount = new BN(0, 10);\n    this.amountLocked = new BN(0, 10);\n    this.amountExtra = new BN(0, 10);\n    this.amountMultisig = new BN(0, 10);\n    this.pow = Big(10).pow(denomination);\n  }\n\n  addBalance(val: BN): void {\n    this.amount = this.amount.add(val);\n  }\n\n  addBalanceLocked(val: BN): void {\n    this.amountLocked = this.amountLocked.add(val);\n  }\n  addBalanceMultisig(val: BN): void {\n    this.amountMultisig = this.amountMultisig.add(val);\n  }\n\n  addExtra(val: BN): void {\n    this.amountExtra = this.amountExtra.add(val);\n  }\n\n  resetBalance() {\n    this.amount = new BN(0, 10);\n    this.amountLocked = new BN(0, 10);\n    this.amountExtra = new BN(0, 10);\n    this.amountMultisig = new BN(0, 10);\n  }\n\n  getAmount(locked: boolean = false): Big {\n    if (!locked) {\n      return Big(this.amount.toString(10)).div(this.pow);\n    } else {\n      return Big(this.amountLocked.toString(10)).div(this.pow);\n    }\n  }\n\n  getAmountBN(locked: boolean = false): BN {\n    if (!locked) {\n      return this.amount;\n    } else {\n      return this.amountLocked;\n    }\n  }\n\n  getTotalAmount(): BN {\n    return this.amount\n      .add(this.amountLocked)\n      .add(this.amountExtra)\n      .add(this.amountMultisig);\n  }\n\n  toStringTotal(): string {\n    const big: Big = Big(this.getTotalAmount().toString(10)).div(this.pow);\n    return big.toLocaleString(this.denomination);\n  }\n\n  toString() {\n    const big: Big = Big(this.amount.toString(10)).div(this.pow);\n    return big.toLocaleString(this.denomination);\n  }\n}\n\nexport default AvaAsset;\n"],"sourceRoot":""}